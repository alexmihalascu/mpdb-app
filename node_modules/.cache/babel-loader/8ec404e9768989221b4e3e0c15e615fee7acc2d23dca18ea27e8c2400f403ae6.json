{"ast":null,"code":"'use strict';\n\nconst {\n  FetchError,\n  Request,\n  isRedirect\n} = require('minipass-fetch');\nconst url = require('url');\nconst CachePolicy = require('./cache/policy.js');\nconst cache = require('./cache/index.js');\nconst remote = require('./remote.js');\n\n// given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status)) return false;\n  if (options.redirect === 'manual') return false;\n  if (options.redirect === 'error') throw new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect', {\n    code: 'ENOREDIRECT'\n  });\n  if (!response.headers.has('location')) throw new FetchError(`redirect location header missing for: ${request.url}`, 'no-location', {\n    code: 'EINVALIDREDIRECT'\n  });\n  if (request.counter >= request.follow) throw new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect', {\n    code: 'EMAXREDIRECT'\n  });\n  return true;\n};\n\n// given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\nconst getRedirect = (request, response, options) => {\n  const _opts = {\n    ...options\n  };\n  const location = response.headers.get('location');\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url);\n  // Comment below is used under the following license:\n  // Copyright (c) 2010-2012 Mikeal Rogers\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  // http://www.apache.org/licenses/LICENSE-2.0\n  // Unless required by applicable law or agreed to in writing,\n  // software distributed under the License is distributed on an \"AS\n  // IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  // express or implied. See the License for the specific language\n  // governing permissions and limitations under the License.\n\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname) request.headers.delete('authorization');\n\n  // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n  if (response.status === 303 || request.method === 'POST' && [301, 302].includes(response.status)) {\n    _opts.method = 'GET';\n    _opts.body = null;\n    request.headers.delete('content-length');\n  }\n  _opts.headers = {};\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value;\n  });\n  _opts.counter = ++request.counter;\n  const redirectReq = new Request(url.format(redirectUrl), _opts);\n  return {\n    request: redirectReq,\n    options: _opts\n  };\n};\nconst fetch = async (request, options) => {\n  const response = CachePolicy.storable(request, options) ? await cache(request, options) : await remote(request, options);\n\n  // if the request wasn't a GET or HEAD, and the response\n  // status is between 200 and 399 inclusive, invalidate the\n  // request url\n  if (!['GET', 'HEAD'].includes(request.method) && response.status >= 200 && response.status <= 399) await cache.invalidate(request, options);\n  if (!canFollowRedirect(request, response, options)) return response;\n  const redirect = getRedirect(request, response, options);\n  return fetch(redirect.request, redirect.options);\n};\nmodule.exports = fetch;","map":{"version":3,"names":["FetchError","Request","isRedirect","require","url","CachePolicy","cache","remote","canFollowRedirect","request","response","options","status","redirect","code","headers","has","counter","follow","getRedirect","_opts","location","get","redirectUrl","URL","test","undefined","hostname","delete","method","includes","body","forEach","value","key","redirectReq","format","fetch","storable","invalidate","module","exports"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/make-fetch-happen/lib/fetch.js"],"sourcesContent":["'use strict'\n\nconst { FetchError, Request, isRedirect } = require('minipass-fetch')\nconst url = require('url')\n\nconst CachePolicy = require('./cache/policy.js')\nconst cache = require('./cache/index.js')\nconst remote = require('./remote.js')\n\n// given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status))\n    return false\n\n  if (options.redirect === 'manual')\n    return false\n\n  if (options.redirect === 'error')\n    throw new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect', { code: 'ENOREDIRECT' })\n\n  if (!response.headers.has('location'))\n    throw new FetchError(`redirect location header missing for: ${request.url}`, 'no-location', { code: 'EINVALIDREDIRECT' })\n\n  if (request.counter >= request.follow)\n    throw new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect', { code: 'EMAXREDIRECT' })\n\n  return true\n}\n\n// given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\nconst getRedirect = (request, response, options) => {\n  const _opts = { ...options }\n  const location = response.headers.get('location')\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url)\n  // Comment below is used under the following license:\n  // Copyright (c) 2010-2012 Mikeal Rogers\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  // http://www.apache.org/licenses/LICENSE-2.0\n  // Unless required by applicable law or agreed to in writing,\n  // software distributed under the License is distributed on an \"AS\n  // IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  // express or implied. See the License for the specific language\n  // governing permissions and limitations under the License.\n\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname)\n    request.headers.delete('authorization')\n\n  // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n  if (response.status === 303 || (request.method === 'POST' && [301, 302].includes(response.status))) {\n    _opts.method = 'GET'\n    _opts.body = null\n    request.headers.delete('content-length')\n  }\n\n  _opts.headers = {}\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value\n  })\n\n  _opts.counter = ++request.counter\n  const redirectReq = new Request(url.format(redirectUrl), _opts)\n  return {\n    request: redirectReq,\n    options: _opts,\n  }\n}\n\nconst fetch = async (request, options) => {\n  const response = CachePolicy.storable(request, options)\n    ? await cache(request, options)\n    : await remote(request, options)\n\n  // if the request wasn't a GET or HEAD, and the response\n  // status is between 200 and 399 inclusive, invalidate the\n  // request url\n  if (!['GET', 'HEAD'].includes(request.method) &&\n      response.status >= 200 &&\n      response.status <= 399)\n    await cache.invalidate(request, options)\n\n  if (!canFollowRedirect(request, response, options))\n    return response\n\n  const redirect = getRedirect(request, response, options)\n  return fetch(redirect.request, redirect.options)\n}\n\nmodule.exports = fetch\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}