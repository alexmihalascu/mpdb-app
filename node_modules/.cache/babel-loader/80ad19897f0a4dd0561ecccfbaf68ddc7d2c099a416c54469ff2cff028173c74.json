{"ast":null,"code":"const {\n  NotCachedError\n} = require('./errors.js');\nconst CacheEntry = require('./entry.js');\nconst remote = require('../remote.js');\n\n// do whatever is necessary to get a Response and return it\nconst cacheFetch = async (request, options) => {\n  // try to find a cached entry that satisfies this request\n  const entry = await CacheEntry.find(request, options);\n  if (!entry) {\n    // no cached result, if the cache mode is 'only-if-cached' that's a failure\n    if (options.cache === 'only-if-cached') throw new NotCachedError(request.url);\n\n    // otherwise, we make a request, store it and return it\n    const response = await remote(request, options);\n    const entry = new CacheEntry({\n      request,\n      response,\n      options\n    });\n    return entry.store('miss');\n  }\n\n  // we have a cached response that satisfies this request, however if the cache\n  // mode is 'no-cache' then we send the revalidation request no matter what\n  if (options.cache === 'no-cache') return entry.revalidate(request, options);\n\n  // if the cached entry is not stale, or if the cache mode is 'force-cache' or\n  // 'only-if-cached' we can respond with the cached entry. set the status\n  // based on the result of needsRevalidation and respond\n  const _needsRevalidation = entry.policy.needsRevalidation(request);\n  if (options.cache === 'force-cache' || options.cache === 'only-if-cached' || !_needsRevalidation) return entry.respond(request.method, options, _needsRevalidation ? 'stale' : 'hit');\n\n  // if we got here, the cache entry is stale so revalidate it\n  return entry.revalidate(request, options);\n};\ncacheFetch.invalidate = async (request, options) => {\n  if (!options.cachePath) return;\n  return CacheEntry.invalidate(request, options);\n};\nmodule.exports = cacheFetch;","map":{"version":3,"names":["NotCachedError","require","CacheEntry","remote","cacheFetch","request","options","entry","find","cache","url","response","store","revalidate","_needsRevalidation","policy","needsRevalidation","respond","method","invalidate","cachePath","module","exports"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/make-fetch-happen/lib/cache/index.js"],"sourcesContent":["const { NotCachedError } = require('./errors.js')\nconst CacheEntry = require('./entry.js')\nconst remote = require('../remote.js')\n\n// do whatever is necessary to get a Response and return it\nconst cacheFetch = async (request, options) => {\n  // try to find a cached entry that satisfies this request\n  const entry = await CacheEntry.find(request, options)\n  if (!entry) {\n    // no cached result, if the cache mode is 'only-if-cached' that's a failure\n    if (options.cache === 'only-if-cached')\n      throw new NotCachedError(request.url)\n\n    // otherwise, we make a request, store it and return it\n    const response = await remote(request, options)\n    const entry = new CacheEntry({ request, response, options })\n    return entry.store('miss')\n  }\n\n  // we have a cached response that satisfies this request, however if the cache\n  // mode is 'no-cache' then we send the revalidation request no matter what\n  if (options.cache === 'no-cache')\n    return entry.revalidate(request, options)\n\n  // if the cached entry is not stale, or if the cache mode is 'force-cache' or\n  // 'only-if-cached' we can respond with the cached entry. set the status\n  // based on the result of needsRevalidation and respond\n  const _needsRevalidation = entry.policy.needsRevalidation(request)\n  if (options.cache === 'force-cache' ||\n      options.cache === 'only-if-cached' ||\n      !_needsRevalidation)\n    return entry.respond(request.method, options, _needsRevalidation ? 'stale' : 'hit')\n\n  // if we got here, the cache entry is stale so revalidate it\n  return entry.revalidate(request, options)\n}\n\ncacheFetch.invalidate = async (request, options) => {\n  if (!options.cachePath)\n    return\n\n  return CacheEntry.invalidate(request, options)\n}\n\nmodule.exports = cacheFetch\n"],"mappings":"AAAA,MAAM;EAAEA;AAAe,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC;AACjD,MAAMC,UAAU,GAAGD,OAAO,CAAC,YAAY,CAAC;AACxC,MAAME,MAAM,GAAGF,OAAO,CAAC,cAAc,CAAC;;AAEtC;AACA,MAAMG,UAAU,GAAG,OAAOC,OAAO,EAAEC,OAAO,KAAK;EAC7C;EACA,MAAMC,KAAK,GAAG,MAAML,UAAU,CAACM,IAAI,CAACH,OAAO,EAAEC,OAAO,CAAC;EACrD,IAAI,CAACC,KAAK,EAAE;IACV;IACA,IAAID,OAAO,CAACG,KAAK,KAAK,gBAAgB,EACpC,MAAM,IAAIT,cAAc,CAACK,OAAO,CAACK,GAAG,CAAC;;IAEvC;IACA,MAAMC,QAAQ,GAAG,MAAMR,MAAM,CAACE,OAAO,EAAEC,OAAO,CAAC;IAC/C,MAAMC,KAAK,GAAG,IAAIL,UAAU,CAAC;MAAEG,OAAO;MAAEM,QAAQ;MAAEL;IAAQ,CAAC,CAAC;IAC5D,OAAOC,KAAK,CAACK,KAAK,CAAC,MAAM,CAAC;EAC5B;;EAEA;EACA;EACA,IAAIN,OAAO,CAACG,KAAK,KAAK,UAAU,EAC9B,OAAOF,KAAK,CAACM,UAAU,CAACR,OAAO,EAAEC,OAAO,CAAC;;EAE3C;EACA;EACA;EACA,MAAMQ,kBAAkB,GAAGP,KAAK,CAACQ,MAAM,CAACC,iBAAiB,CAACX,OAAO,CAAC;EAClE,IAAIC,OAAO,CAACG,KAAK,KAAK,aAAa,IAC/BH,OAAO,CAACG,KAAK,KAAK,gBAAgB,IAClC,CAACK,kBAAkB,EACrB,OAAOP,KAAK,CAACU,OAAO,CAACZ,OAAO,CAACa,MAAM,EAAEZ,OAAO,EAAEQ,kBAAkB,GAAG,OAAO,GAAG,KAAK,CAAC;;EAErF;EACA,OAAOP,KAAK,CAACM,UAAU,CAACR,OAAO,EAAEC,OAAO,CAAC;AAC3C,CAAC;AAEDF,UAAU,CAACe,UAAU,GAAG,OAAOd,OAAO,EAAEC,OAAO,KAAK;EAClD,IAAI,CAACA,OAAO,CAACc,SAAS,EACpB;EAEF,OAAOlB,UAAU,CAACiB,UAAU,CAACd,OAAO,EAAEC,OAAO,CAAC;AAChD,CAAC;AAEDe,MAAM,CAACC,OAAO,GAAGlB,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}