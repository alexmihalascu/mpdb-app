{"ast":null,"code":"'use strict';\n\nconst AggregateError = require('aggregate-error');\nmodule.exports = async function (iterable, mapper) {\n  let {\n    concurrency = Infinity,\n    stopOnError = true\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new Promise((resolve, reject) => {\n    if (typeof mapper !== 'function') {\n      throw new TypeError('Mapper function is required');\n    }\n    if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n      throw new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n    }\n    const result = [];\n    const errors = [];\n    const iterator = iterable[Symbol.iterator]();\n    let isRejected = false;\n    let isIterableDone = false;\n    let resolvingCount = 0;\n    let currentIndex = 0;\n    const next = () => {\n      if (isRejected) {\n        return;\n      }\n      const nextItem = iterator.next();\n      const index = currentIndex;\n      currentIndex++;\n      if (nextItem.done) {\n        isIterableDone = true;\n        if (resolvingCount === 0) {\n          if (!stopOnError && errors.length !== 0) {\n            reject(new AggregateError(errors));\n          } else {\n            resolve(result);\n          }\n        }\n        return;\n      }\n      resolvingCount++;\n      (async () => {\n        try {\n          const element = await nextItem.value;\n          result[index] = await mapper(element, index);\n          resolvingCount--;\n          next();\n        } catch (error) {\n          if (stopOnError) {\n            isRejected = true;\n            reject(error);\n          } else {\n            errors.push(error);\n            resolvingCount--;\n            next();\n          }\n        }\n      })();\n    };\n    for (let i = 0; i < concurrency; i++) {\n      next();\n      if (isIterableDone) {\n        break;\n      }\n    }\n  });\n};","map":{"version":3,"names":["AggregateError","require","module","exports","iterable","mapper","concurrency","Infinity","stopOnError","Promise","resolve","reject","TypeError","Number","isSafeInteger","result","errors","iterator","Symbol","isRejected","isIterableDone","resolvingCount","currentIndex","next","nextItem","index","done","length","element","value","error","push","i"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/p-map/index.js"],"sourcesContent":["'use strict';\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = async (\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Infinity,\n\t\tstopOnError = true\n\t} = {}\n) => {\n\treturn new Promise((resolve, reject) => {\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst iterator = iterable[Symbol.iterator]();\n\t\tlet isRejected = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\n\t\tconst next = () => {\n\t\t\tif (isRejected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = iterator.next();\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0) {\n\t\t\t\t\tif (!stopOnError && errors.length !== 0) {\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\t\t\t\t\tresult[index] = await mapper(element, index);\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\tisRejected = true;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\tfor (let i = 0; i < concurrency; i++) {\n\t\t\tnext();\n\n\t\t\tif (isIterableDone) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n};\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,cAAc,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAEjDC,MAAM,CAACC,OAAO,GAAG,gBAChBC,QAAQ,EACRC,MAAM,EAKF;EAAA,IAJJ;IACCC,WAAW,GAAGC,QAAQ;IACtBC,WAAW,GAAG;EACf,CAAC,uEAAG,CAAC,CAAC;EAEN,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACvC,IAAI,OAAON,MAAM,KAAK,UAAU,EAAE;MACjC,MAAM,IAAIO,SAAS,CAAC,6BAA6B,CAAC;IACnD;IAEA,IAAI,EAAE,CAACC,MAAM,CAACC,aAAa,CAACR,WAAW,CAAC,IAAIA,WAAW,KAAKC,QAAQ,KAAKD,WAAW,IAAI,CAAC,CAAC,EAAE;MAC3F,MAAM,IAAIM,SAAS,CAAE,kFAAiFN,WAAY,OAAM,OAAOA,WAAY,GAAE,CAAC;IAC/I;IAEA,MAAMS,MAAM,GAAG,EAAE;IACjB,MAAMC,MAAM,GAAG,EAAE;IACjB,MAAMC,QAAQ,GAAGb,QAAQ,CAACc,MAAM,CAACD,QAAQ,CAAC,EAAE;IAC5C,IAAIE,UAAU,GAAG,KAAK;IACtB,IAAIC,cAAc,GAAG,KAAK;IAC1B,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAIC,YAAY,GAAG,CAAC;IAEpB,MAAMC,IAAI,GAAG,MAAM;MAClB,IAAIJ,UAAU,EAAE;QACf;MACD;MAEA,MAAMK,QAAQ,GAAGP,QAAQ,CAACM,IAAI,EAAE;MAChC,MAAME,KAAK,GAAGH,YAAY;MAC1BA,YAAY,EAAE;MAEd,IAAIE,QAAQ,CAACE,IAAI,EAAE;QAClBN,cAAc,GAAG,IAAI;QAErB,IAAIC,cAAc,KAAK,CAAC,EAAE;UACzB,IAAI,CAACb,WAAW,IAAIQ,MAAM,CAACW,MAAM,KAAK,CAAC,EAAE;YACxChB,MAAM,CAAC,IAAIX,cAAc,CAACgB,MAAM,CAAC,CAAC;UACnC,CAAC,MAAM;YACNN,OAAO,CAACK,MAAM,CAAC;UAChB;QACD;QAEA;MACD;MAEAM,cAAc,EAAE;MAEhB,CAAC,YAAY;QACZ,IAAI;UACH,MAAMO,OAAO,GAAG,MAAMJ,QAAQ,CAACK,KAAK;UACpCd,MAAM,CAACU,KAAK,CAAC,GAAG,MAAMpB,MAAM,CAACuB,OAAO,EAAEH,KAAK,CAAC;UAC5CJ,cAAc,EAAE;UAChBE,IAAI,EAAE;QACP,CAAC,CAAC,OAAOO,KAAK,EAAE;UACf,IAAItB,WAAW,EAAE;YAChBW,UAAU,GAAG,IAAI;YACjBR,MAAM,CAACmB,KAAK,CAAC;UACd,CAAC,MAAM;YACNd,MAAM,CAACe,IAAI,CAACD,KAAK,CAAC;YAClBT,cAAc,EAAE;YAChBE,IAAI,EAAE;UACP;QACD;MACD,CAAC,GAAG;IACL,CAAC;IAED,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1B,WAAW,EAAE0B,CAAC,EAAE,EAAE;MACrCT,IAAI,EAAE;MAEN,IAAIH,cAAc,EAAE;QACnB;MACD;IACD;EACD,CAAC,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}