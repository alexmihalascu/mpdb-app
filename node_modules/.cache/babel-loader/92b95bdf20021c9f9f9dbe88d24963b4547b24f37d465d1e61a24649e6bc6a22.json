{"ast":null,"code":"const Minipass = require('minipass');\nconst MinipassPipeline = require('minipass-pipeline');\nconst fetch = require('minipass-fetch');\nconst promiseRetry = require('promise-retry');\nconst ssri = require('ssri');\nconst getAgent = require('./agent.js');\nconst pkg = require('../package.json');\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET',\n// remote socket closed on us\n'ECONNREFUSED',\n// remote host refused to open connection\n'EADDRINUSE',\n// failed to bind to a local port (proxy?)\n'ETIMEDOUT',\n// someone in the transaction is WAY TOO SLOW\n'ERR_SOCKET_TIMEOUT' // same as above, but this one comes from agentkeepalive\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\n\nconst RETRY_TYPES = ['request-timeout'];\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options);\n  if (!request.headers.has('connection')) request.headers.set('connection', agent ? 'keep-alive' : 'close');\n  if (!request.headers.has('user-agent')) request.headers.set('user-agent', USER_AGENT);\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  const _opts = {\n    ...options,\n    agent,\n    redirect: 'manual'\n  };\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts);\n    try {\n      let res = await fetch(req, _opts);\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({\n          integrity: _opts.integrity\n        });\n        res = new fetch.Response(new MinipassPipeline(res.body, integrityStream), res);\n      }\n      res.headers.set('x-fetch-attempts', attemptNum);\n\n      // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n      const isStream = Minipass.isStream(req.body);\n      const isRetriable = req.method !== 'POST' && !isStream && ([408, 420, 429].includes(res.status) || res.status >= 500);\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function') options.onRetry(res);\n        return retryHandler(res);\n      }\n      return res;\n    } catch (err) {\n      const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code;\n\n      // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n      const isRetryError = err.retried instanceof fetch.Response || RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type);\n      if (req.method === 'POST' || isRetryError) throw err;\n      if (typeof options.onRetry === 'function') options.onRetry(err);\n      return retryHandler(err);\n    }\n  }, options.retry).catch(err => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') return err;\n    throw err;\n  });\n};\nmodule.exports = remoteFetch;","map":{"version":3,"names":["Minipass","require","MinipassPipeline","fetch","promiseRetry","ssri","getAgent","pkg","USER_AGENT","name","version","RETRY_ERRORS","RETRY_TYPES","remoteFetch","request","options","agent","url","headers","has","set","_opts","redirect","retryHandler","attemptNum","req","Request","res","integrity","status","integrityStream","Response","body","isStream","isRetriable","method","includes","onRetry","err","code","retried","isRetryError","type","retry","catch","module","exports"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/make-fetch-happen/lib/remote.js"],"sourcesContent":["const Minipass = require('minipass')\nconst MinipassPipeline = require('minipass-pipeline')\nconst fetch = require('minipass-fetch')\nconst promiseRetry = require('promise-retry')\nconst ssri = require('ssri')\n\nconst getAgent = require('./agent.js')\nconst pkg = require('../package.json')\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`\n\nconst RETRY_ERRORS = [\n  'ECONNRESET', // remote socket closed on us\n  'ECONNREFUSED', // remote host refused to open connection\n  'EADDRINUSE', // failed to bind to a local port (proxy?)\n  'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n  'ERR_SOCKET_TIMEOUT', // same as above, but this one comes from agentkeepalive\n  // Known codes we do NOT retry on:\n  // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n]\n\nconst RETRY_TYPES = [\n  'request-timeout',\n]\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options)\n  if (!request.headers.has('connection'))\n    request.headers.set('connection', agent ? 'keep-alive' : 'close')\n\n  if (!request.headers.has('user-agent'))\n    request.headers.set('user-agent', USER_AGENT)\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  const _opts = {\n    ...options,\n    agent,\n    redirect: 'manual',\n  }\n\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts)\n    try {\n      let res = await fetch(req, _opts)\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({ integrity: _opts.integrity })\n        res = new fetch.Response(new MinipassPipeline(res.body, integrityStream), res)\n      }\n\n      res.headers.set('x-fetch-attempts', attemptNum)\n\n      // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n      const isStream = Minipass.isStream(req.body)\n      const isRetriable = req.method !== 'POST' &&\n          !isStream &&\n          ([408, 420, 429].includes(res.status) || res.status >= 500)\n\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function')\n          options.onRetry(res)\n\n        return retryHandler(res)\n      }\n\n      return res\n    } catch (err) {\n      const code = (err.code === 'EPROMISERETRY')\n        ? err.retried.code\n        : err.code\n\n      // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n      const isRetryError = err.retried instanceof fetch.Response ||\n        (RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type))\n\n      if (req.method === 'POST' || isRetryError)\n        throw err\n\n      if (typeof options.onRetry === 'function')\n        options.onRetry(err)\n\n      return retryHandler(err)\n    }\n  }, options.retry).catch((err) => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system')\n      return err\n\n    throw err\n  })\n}\n\nmodule.exports = remoteFetch\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}