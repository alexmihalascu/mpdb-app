{"ast":null,"code":"// this file is a modified version of the code in node 17.2.0\n// which is, in turn, a modified version of the fs-extra module on npm\n// node core changes:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n// changes here:\n// - remove all callback related code\n// - drop sync support\n// - change assertions back to non-internal methods (see options.js)\n// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows\n'use strict';\n\nconst {\n  ERR_FS_CP_DIR_TO_NON_DIR,\n  ERR_FS_CP_EEXIST,\n  ERR_FS_CP_EINVAL,\n  ERR_FS_CP_FIFO_PIPE,\n  ERR_FS_CP_NON_DIR_TO_DIR,\n  ERR_FS_CP_SOCKET,\n  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,\n  ERR_FS_CP_UNKNOWN,\n  ERR_FS_EISDIR,\n  ERR_INVALID_ARG_TYPE\n} = require('../errors.js');\nconst {\n  constants: {\n    errno: {\n      EEXIST,\n      EISDIR,\n      EINVAL,\n      ENOTDIR\n    }\n  }\n} = require('os');\nconst {\n  chmod,\n  copyFile,\n  lstat,\n  mkdir,\n  readdir,\n  readlink,\n  stat,\n  symlink,\n  unlink,\n  utimes\n} = require('../fs.js');\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  parse,\n  resolve,\n  sep,\n  toNamespacedPath\n} = require('path');\nconst {\n  fileURLToPath\n} = require('url');\nconst defaultOptions = {\n  dereference: false,\n  errorOnExist: false,\n  filter: undefined,\n  force: true,\n  preserveTimestamps: false,\n  recursive: false\n};\nasync function cp(src, dest, opts) {\n  if (opts != null && typeof opts !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options', ['Object'], opts);\n  }\n  return cpFn(toNamespacedPath(getValidatedPath(src)), toNamespacedPath(getValidatedPath(dest)), {\n    ...defaultOptions,\n    ...opts\n  });\n}\nfunction getValidatedPath(fileURLOrPath) {\n  const path = fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin ? fileURLToPath(fileURLOrPath) : fileURLOrPath;\n  return path;\n}\nasync function cpFn(src, dest, opts) {\n  // Warn about using preserveTimestamps on 32-bit node\n  // istanbul ignore next\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    const warning = 'Using the preserveTimestamps option in 32-bit ' + 'node is not recommended';\n    process.emitWarning(warning, 'TimestampPrecisionWarning');\n  }\n  const stats = await checkPaths(src, dest, opts);\n  const {\n    srcStat,\n    destStat\n  } = stats;\n  await checkParentPaths(src, srcStat, dest);\n  if (opts.filter) {\n    return handleFilter(checkParentDir, destStat, src, dest, opts);\n  }\n  return checkParentDir(destStat, src, dest, opts);\n}\nasync function checkPaths(src, dest, opts) {\n  const {\n    0: srcStat,\n    1: destStat\n  } = await getStats(src, dest, opts);\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: 'src and dest cannot be the same',\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new ERR_FS_CP_DIR_TO_NON_DIR({\n        message: `cannot overwrite directory ${src} ` + `with non-directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EISDIR\n      });\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new ERR_FS_CP_NON_DIR_TO_DIR({\n        message: `cannot overwrite non-directory ${src} ` + `with directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: ENOTDIR\n      });\n    }\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}\nfunction areIdentical(srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n}\nfunction getStats(src, dest, opts) {\n  const statFunc = opts.dereference ? file => stat(file, {\n    bigint: true\n  }) : file => lstat(file, {\n    bigint: true\n  });\n  return Promise.all([statFunc(src), statFunc(dest).catch(err => {\n    // istanbul ignore next: unsure how to cover.\n    if (err.code === 'ENOENT') {\n      return null;\n    }\n    // istanbul ignore next: unsure how to cover.\n    throw err;\n  })]);\n}\nasync function checkParentDir(destStat, src, dest, opts) {\n  const destParent = dirname(dest);\n  const dirExists = await pathExists(destParent);\n  if (dirExists) {\n    return getStatsForCopy(destStat, src, dest, opts);\n  }\n  await mkdir(destParent, {\n    recursive: true\n  });\n  return getStatsForCopy(destStat, src, dest, opts);\n}\nfunction pathExists(dest) {\n  return stat(dest).then(() => true,\n  // istanbul ignore next: not sure when this would occur\n  err => err.code === 'ENOENT' ? false : Promise.reject(err));\n}\n\n// Recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nasync function checkParentPaths(src, srcStat, dest) {\n  const srcParent = resolve(dirname(src));\n  const destParent = resolve(dirname(dest));\n  if (destParent === srcParent || destParent === parse(destParent).root) {\n    return;\n  }\n  let destStat;\n  try {\n    destStat = await stat(destParent, {\n      bigint: true\n    });\n  } catch (err) {\n    // istanbul ignore else: not sure when this would occur\n    if (err.code === 'ENOENT') {\n      return;\n    }\n    // istanbul ignore next: not sure when this would occur\n    throw err;\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  }\n  return checkParentPaths(src, srcStat, destParent);\n}\nconst normalizePathToArray = path => resolve(path).split(sep).filter(Boolean);\n\n// Return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir(src, dest) {\n  const srcArr = normalizePathToArray(src);\n  const destArr = normalizePathToArray(dest);\n  return srcArr.every((cur, i) => destArr[i] === cur);\n}\nasync function handleFilter(onInclude, destStat, src, dest, opts, cb) {\n  const include = await opts.filter(src, dest);\n  if (include) {\n    return onInclude(destStat, src, dest, opts, cb);\n  }\n}\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter) {\n    return handleFilter(getStatsForCopy, destStat, src, dest, opts);\n  }\n  return getStatsForCopy(destStat, src, dest, opts);\n}\nasync function getStatsForCopy(destStat, src, dest, opts) {\n  const statFn = opts.dereference ? stat : lstat;\n  const srcStat = await statFn(src);\n  // istanbul ignore else: can't portably test FIFO\n  if (srcStat.isDirectory() && opts.recursive) {\n    return onDir(srcStat, destStat, src, dest, opts);\n  } else if (srcStat.isDirectory()) {\n    throw new ERR_FS_EISDIR({\n      message: `${src} is a directory (not copied)`,\n      path: src,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {\n    return onFile(srcStat, destStat, src, dest, opts);\n  } else if (srcStat.isSymbolicLink()) {\n    return onLink(destStat, src, dest);\n  } else if (srcStat.isSocket()) {\n    throw new ERR_FS_CP_SOCKET({\n      message: `cannot copy a socket file: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  } else if (srcStat.isFIFO()) {\n    throw new ERR_FS_CP_FIFO_PIPE({\n      message: `cannot copy a FIFO pipe: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  }\n  // istanbul ignore next: should be unreachable\n  throw new ERR_FS_CP_UNKNOWN({\n    message: `cannot copy an unknown file type: ${dest}`,\n    path: dest,\n    syscall: 'cp',\n    errno: EINVAL\n  });\n}\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return _copyFile(srcStat, src, dest, opts);\n  }\n  return mayCopyFile(srcStat, src, dest, opts);\n}\nasync function mayCopyFile(srcStat, src, dest, opts) {\n  if (opts.force) {\n    await unlink(dest);\n    return _copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new ERR_FS_CP_EEXIST({\n      message: `${dest} already exists`,\n      path: dest,\n      syscall: 'cp',\n      errno: EEXIST\n    });\n  }\n}\nasync function _copyFile(srcStat, src, dest, opts) {\n  await copyFile(src, dest);\n  if (opts.preserveTimestamps) {\n    return handleTimestampsAndMode(srcStat.mode, src, dest);\n  }\n  return setDestMode(dest, srcStat.mode);\n}\nasync function handleTimestampsAndMode(srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    await makeFileWritable(dest, srcMode);\n    return setDestTimestampsAndMode(srcMode, src, dest);\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest);\n}\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\nfunction makeFileWritable(dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200);\n}\nasync function setDestTimestampsAndMode(srcMode, src, dest) {\n  await setDestTimestamps(src, dest);\n  return setDestMode(dest, srcMode);\n}\nfunction setDestMode(dest, srcMode) {\n  return chmod(dest, srcMode);\n}\nasync function setDestTimestamps(src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = await stat(src);\n  return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n}\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  }\n  return copyDir(src, dest, opts);\n}\nasync function mkDirAndCopy(srcMode, src, dest, opts) {\n  await mkdir(dest);\n  await copyDir(src, dest, opts);\n  return setDestMode(dest, srcMode);\n}\nasync function copyDir(src, dest, opts) {\n  const dir = await readdir(src);\n  for (let i = 0; i < dir.length; i++) {\n    const item = dir[i];\n    const srcItem = join(src, item);\n    const destItem = join(dest, item);\n    const {\n      destStat\n    } = await checkPaths(srcItem, destItem, opts);\n    await startCopy(destStat, srcItem, destItem, opts);\n  }\n}\nasync function onLink(destStat, src, dest) {\n  let resolvedSrc = await readlink(src);\n  if (!isAbsolute(resolvedSrc)) {\n    resolvedSrc = resolve(dirname(src), resolvedSrc);\n  }\n  if (!destStat) {\n    return symlink(resolvedSrc, dest);\n  }\n  let resolvedDest;\n  try {\n    resolvedDest = await readlink(dest);\n  } catch (err) {\n    // Dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    // istanbul ignore next: can only test on windows\n    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {\n      return symlink(resolvedSrc, dest);\n    }\n    // istanbul ignore next: should not be possible\n    throw err;\n  }\n  if (!isAbsolute(resolvedDest)) {\n    resolvedDest = resolve(dirname(dest), resolvedDest);\n  }\n  if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` + `${resolvedDest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  }\n  // Do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  const srcStat = await stat(src);\n  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({\n      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  }\n  return copyLink(resolvedSrc, dest);\n}\nasync function copyLink(resolvedSrc, dest) {\n  await unlink(dest);\n  return symlink(resolvedSrc, dest);\n}\nmodule.exports = cp;","map":{"version":3,"names":["ERR_FS_CP_DIR_TO_NON_DIR","ERR_FS_CP_EEXIST","ERR_FS_CP_EINVAL","ERR_FS_CP_FIFO_PIPE","ERR_FS_CP_NON_DIR_TO_DIR","ERR_FS_CP_SOCKET","ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY","ERR_FS_CP_UNKNOWN","ERR_FS_EISDIR","ERR_INVALID_ARG_TYPE","require","constants","errno","EEXIST","EISDIR","EINVAL","ENOTDIR","chmod","copyFile","lstat","mkdir","readdir","readlink","stat","symlink","unlink","utimes","dirname","isAbsolute","join","parse","resolve","sep","toNamespacedPath","fileURLToPath","defaultOptions","dereference","errorOnExist","filter","undefined","force","preserveTimestamps","recursive","cp","src","dest","opts","cpFn","getValidatedPath","fileURLOrPath","path","href","origin","process","arch","warning","emitWarning","stats","checkPaths","srcStat","destStat","checkParentPaths","handleFilter","checkParentDir","getStats","areIdentical","message","syscall","isDirectory","isSrcSubdir","ino","dev","statFunc","file","bigint","Promise","all","catch","err","code","destParent","dirExists","pathExists","getStatsForCopy","then","reject","srcParent","root","normalizePathToArray","split","Boolean","srcArr","destArr","every","cur","i","onInclude","cb","include","startCopy","statFn","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","isSocket","isFIFO","_copyFile","mayCopyFile","handleTimestampsAndMode","mode","setDestMode","srcMode","fileIsNotWritable","makeFileWritable","setDestTimestampsAndMode","setDestTimestamps","updatedSrcStat","atime","mtime","mkDirAndCopy","copyDir","dir","length","item","srcItem","destItem","resolvedSrc","resolvedDest","copyLink","module","exports"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/@npmcli/fs/lib/cp/polyfill.js"],"sourcesContent":["// this file is a modified version of the code in node 17.2.0\n// which is, in turn, a modified version of the fs-extra module on npm\n// node core changes:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n// changes here:\n// - remove all callback related code\n// - drop sync support\n// - change assertions back to non-internal methods (see options.js)\n// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows\n'use strict'\n\nconst {\n  ERR_FS_CP_DIR_TO_NON_DIR,\n  ERR_FS_CP_EEXIST,\n  ERR_FS_CP_EINVAL,\n  ERR_FS_CP_FIFO_PIPE,\n  ERR_FS_CP_NON_DIR_TO_DIR,\n  ERR_FS_CP_SOCKET,\n  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,\n  ERR_FS_CP_UNKNOWN,\n  ERR_FS_EISDIR,\n  ERR_INVALID_ARG_TYPE,\n} = require('../errors.js')\nconst {\n  constants: {\n    errno: {\n      EEXIST,\n      EISDIR,\n      EINVAL,\n      ENOTDIR,\n    },\n  },\n} = require('os')\nconst {\n  chmod,\n  copyFile,\n  lstat,\n  mkdir,\n  readdir,\n  readlink,\n  stat,\n  symlink,\n  unlink,\n  utimes,\n} = require('../fs.js')\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  parse,\n  resolve,\n  sep,\n  toNamespacedPath,\n} = require('path')\nconst { fileURLToPath } = require('url')\n\nconst defaultOptions = {\n  dereference: false,\n  errorOnExist: false,\n  filter: undefined,\n  force: true,\n  preserveTimestamps: false,\n  recursive: false,\n}\n\nasync function cp (src, dest, opts) {\n  if (opts != null && typeof opts !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options', ['Object'], opts)\n  }\n  return cpFn(\n    toNamespacedPath(getValidatedPath(src)),\n    toNamespacedPath(getValidatedPath(dest)),\n    { ...defaultOptions, ...opts })\n}\n\nfunction getValidatedPath (fileURLOrPath) {\n  const path = fileURLOrPath != null && fileURLOrPath.href\n      && fileURLOrPath.origin\n    ? fileURLToPath(fileURLOrPath)\n    : fileURLOrPath\n  return path\n}\n\nasync function cpFn (src, dest, opts) {\n  // Warn about using preserveTimestamps on 32-bit node\n  // istanbul ignore next\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    const warning = 'Using the preserveTimestamps option in 32-bit ' +\n      'node is not recommended'\n    process.emitWarning(warning, 'TimestampPrecisionWarning')\n  }\n  const stats = await checkPaths(src, dest, opts)\n  const { srcStat, destStat } = stats\n  await checkParentPaths(src, srcStat, dest)\n  if (opts.filter) {\n    return handleFilter(checkParentDir, destStat, src, dest, opts)\n  }\n  return checkParentDir(destStat, src, dest, opts)\n}\n\nasync function checkPaths (src, dest, opts) {\n  const { 0: srcStat, 1: destStat } = await getStats(src, dest, opts)\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: 'src and dest cannot be the same',\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL,\n      })\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new ERR_FS_CP_DIR_TO_NON_DIR({\n        message: `cannot overwrite directory ${src} ` +\n            `with non-directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EISDIR,\n      })\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new ERR_FS_CP_NON_DIR_TO_DIR({\n        message: `cannot overwrite non-directory ${src} ` +\n            `with directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: ENOTDIR,\n      })\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  return { srcStat, destStat }\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino &&\n    destStat.dev === srcStat.dev\n}\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference ?\n    (file) => stat(file, { bigint: true }) :\n    (file) => lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch((err) => {\n      // istanbul ignore next: unsure how to cover.\n      if (err.code === 'ENOENT') {\n        return null\n      }\n      // istanbul ignore next: unsure how to cover.\n      throw err\n    }),\n  ])\n}\n\nasync function checkParentDir (destStat, src, dest, opts) {\n  const destParent = dirname(dest)\n  const dirExists = await pathExists(destParent)\n  if (dirExists) {\n    return getStatsForCopy(destStat, src, dest, opts)\n  }\n  await mkdir(destParent, { recursive: true })\n  return getStatsForCopy(destStat, src, dest, opts)\n}\n\nfunction pathExists (dest) {\n  return stat(dest).then(\n    () => true,\n    // istanbul ignore next: not sure when this would occur\n    (err) => (err.code === 'ENOENT' ? false : Promise.reject(err)))\n}\n\n// Recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nasync function checkParentPaths (src, srcStat, dest) {\n  const srcParent = resolve(dirname(src))\n  const destParent = resolve(dirname(dest))\n  if (destParent === srcParent || destParent === parse(destParent).root) {\n    return\n  }\n  let destStat\n  try {\n    destStat = await stat(destParent, { bigint: true })\n  } catch (err) {\n    // istanbul ignore else: not sure when this would occur\n    if (err.code === 'ENOENT') {\n      return\n    }\n    // istanbul ignore next: not sure when this would occur\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  return checkParentPaths(src, srcStat, destParent)\n}\n\nconst normalizePathToArray = (path) =>\n  resolve(path).split(sep).filter(Boolean)\n\n// Return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = normalizePathToArray(src)\n  const destArr = normalizePathToArray(dest)\n  return srcArr.every((cur, i) => destArr[i] === cur)\n}\n\nasync function handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  const include = await opts.filter(src, dest)\n  if (include) {\n    return onInclude(destStat, src, dest, opts, cb)\n  }\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter) {\n    return handleFilter(getStatsForCopy, destStat, src, dest, opts)\n  }\n  return getStatsForCopy(destStat, src, dest, opts)\n}\n\nasync function getStatsForCopy (destStat, src, dest, opts) {\n  const statFn = opts.dereference ? stat : lstat\n  const srcStat = await statFn(src)\n  // istanbul ignore else: can't portably test FIFO\n  if (srcStat.isDirectory() && opts.recursive) {\n    return onDir(srcStat, destStat, src, dest, opts)\n  } else if (srcStat.isDirectory()) {\n    throw new ERR_FS_EISDIR({\n      message: `${src} is a directory (not copied)`,\n      path: src,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  } else if (srcStat.isFile() ||\n            srcStat.isCharacterDevice() ||\n            srcStat.isBlockDevice()) {\n    return onFile(srcStat, destStat, src, dest, opts)\n  } else if (srcStat.isSymbolicLink()) {\n    return onLink(destStat, src, dest)\n  } else if (srcStat.isSocket()) {\n    throw new ERR_FS_CP_SOCKET({\n      message: `cannot copy a socket file: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  } else if (srcStat.isFIFO()) {\n    throw new ERR_FS_CP_FIFO_PIPE({\n      message: `cannot copy a FIFO pipe: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  // istanbul ignore next: should be unreachable\n  throw new ERR_FS_CP_UNKNOWN({\n    message: `cannot copy an unknown file type: ${dest}`,\n    path: dest,\n    syscall: 'cp',\n    errno: EINVAL,\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return _copyFile(srcStat, src, dest, opts)\n  }\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nasync function mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.force) {\n    await unlink(dest)\n    return _copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new ERR_FS_CP_EEXIST({\n      message: `${dest} already exists`,\n      path: dest,\n      syscall: 'cp',\n      errno: EEXIST,\n    })\n  }\n}\n\nasync function _copyFile (srcStat, src, dest, opts) {\n  await copyFile(src, dest)\n  if (opts.preserveTimestamps) {\n    return handleTimestampsAndMode(srcStat.mode, src, dest)\n  }\n  return setDestMode(dest, srcStat.mode)\n}\n\nasync function handleTimestampsAndMode (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    await makeFileWritable(dest, srcMode)\n    return setDestTimestampsAndMode(srcMode, src, dest)\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nasync function setDestTimestampsAndMode (srcMode, src, dest) {\n  await setDestTimestamps(src, dest)\n  return setDestMode(dest, srcMode)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return chmod(dest, srcMode)\n}\n\nasync function setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = await stat(src)\n  return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  }\n  return copyDir(src, dest, opts)\n}\n\nasync function mkDirAndCopy (srcMode, src, dest, opts) {\n  await mkdir(dest)\n  await copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nasync function copyDir (src, dest, opts) {\n  const dir = await readdir(src)\n  for (let i = 0; i < dir.length; i++) {\n    const item = dir[i]\n    const srcItem = join(src, item)\n    const destItem = join(dest, item)\n    const { destStat } = await checkPaths(srcItem, destItem, opts)\n    await startCopy(destStat, srcItem, destItem, opts)\n  }\n}\n\nasync function onLink (destStat, src, dest) {\n  let resolvedSrc = await readlink(src)\n  if (!isAbsolute(resolvedSrc)) {\n    resolvedSrc = resolve(dirname(src), resolvedSrc)\n  }\n  if (!destStat) {\n    return symlink(resolvedSrc, dest)\n  }\n  let resolvedDest\n  try {\n    resolvedDest = await readlink(dest)\n  } catch (err) {\n    // Dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    // istanbul ignore next: can only test on windows\n    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {\n      return symlink(resolvedSrc, dest)\n    }\n    // istanbul ignore next: should not be possible\n    throw err\n  }\n  if (!isAbsolute(resolvedDest)) {\n    resolvedDest = resolve(dirname(dest), resolvedDest)\n  }\n  if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` +\n            `${resolvedDest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  // Do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  const srcStat = await stat(src)\n  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({\n      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  return copyLink(resolvedSrc, dest)\n}\n\nasync function copyLink (resolvedSrc, dest) {\n  await unlink(dest)\n  return symlink(resolvedSrc, dest)\n}\n\nmodule.exports = cp\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}