{"ast":null,"code":"'use strict';\n\nconst util = require('util');\nconst pMap = require('p-map');\nconst contentPath = require('./content/path');\nconst fixOwner = require('./util/fix-owner');\nconst fs = require('fs');\nconst fsm = require('fs-minipass');\nconst glob = util.promisify(require('glob'));\nconst index = require('./entry-index');\nconst path = require('path');\nconst rimraf = util.promisify(require('rimraf'));\nconst ssri = require('ssri');\nconst hasOwnProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\nconst stat = util.promisify(fs.stat);\nconst truncate = util.promisify(fs.truncate);\nconst writeFile = util.promisify(fs.writeFile);\nconst readFile = util.promisify(fs.readFile);\nconst verifyOpts = opts => ({\n  concurrency: 20,\n  log: {\n    silly() {}\n  },\n  ...opts\n});\nmodule.exports = verify;\nfunction verify(cache, opts) {\n  opts = verifyOpts(opts);\n  opts.log.silly('verify', 'verifying cache at', cache);\n  const steps = [markStartTime, fixPerms, garbageCollect, rebuildIndex, cleanTmp, writeVerifile, markEndTime];\n  return steps.reduce((promise, step, i) => {\n    const label = step.name;\n    const start = new Date();\n    return promise.then(stats => {\n      return step(cache, opts).then(s => {\n        s && Object.keys(s).forEach(k => {\n          stats[k] = s[k];\n        });\n        const end = new Date();\n        if (!stats.runTime) stats.runTime = {};\n        stats.runTime[label] = end - start;\n        return Promise.resolve(stats);\n      });\n    });\n  }, Promise.resolve({})).then(stats => {\n    stats.runTime.total = stats.endTime - stats.startTime;\n    opts.log.silly('verify', 'verification finished for', cache, 'in', `${stats.runTime.total}ms`);\n    return stats;\n  });\n}\nfunction markStartTime(cache, opts) {\n  return Promise.resolve({\n    startTime: new Date()\n  });\n}\nfunction markEndTime(cache, opts) {\n  return Promise.resolve({\n    endTime: new Date()\n  });\n}\nfunction fixPerms(cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions');\n  return fixOwner.mkdirfix(cache, cache).then(() => {\n    // TODO - fix file permissions too\n    return fixOwner.chownr(cache, cache);\n  }).then(() => null);\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nfunction garbageCollect(cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content');\n  const indexStream = index.lsStream(cache);\n  const liveContent = new Set();\n  indexStream.on('data', entry => {\n    if (opts.filter && !opts.filter(entry)) return;\n    liveContent.add(entry.integrity.toString());\n  });\n  return new Promise((resolve, reject) => {\n    indexStream.on('end', resolve).on('error', reject);\n  }).then(() => {\n    const contentDir = contentPath.contentDir(cache);\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    }).then(files => {\n      return Promise.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0\n      }).then(stats => pMap(files, f => {\n        const split = f.split(/[/\\\\]/);\n        const digest = split.slice(split.length - 3).join('');\n        const algo = split[split.length - 4];\n        const integrity = ssri.fromHex(digest, algo);\n        if (liveContent.has(integrity.toString())) {\n          return verifyContent(f, integrity).then(info => {\n            if (!info.valid) {\n              stats.reclaimedCount++;\n              stats.badContentCount++;\n              stats.reclaimedSize += info.size;\n            } else {\n              stats.verifiedContent++;\n              stats.keptSize += info.size;\n            }\n            return stats;\n          });\n        } else {\n          // No entries refer to this content. We can delete.\n          stats.reclaimedCount++;\n          return stat(f).then(s => {\n            return rimraf(f).then(() => {\n              stats.reclaimedSize += s.size;\n              return stats;\n            });\n          });\n        }\n      }, {\n        concurrency: opts.concurrency\n      }).then(() => stats));\n    });\n  });\n}\nfunction verifyContent(filepath, sri) {\n  return stat(filepath).then(s => {\n    const contentInfo = {\n      size: s.size,\n      valid: true\n    };\n    return ssri.checkStream(new fsm.ReadStream(filepath), sri).catch(err => {\n      if (err.code !== 'EINTEGRITY') throw err;\n      return rimraf(filepath).then(() => {\n        contentInfo.valid = false;\n      });\n    }).then(() => contentInfo);\n  }).catch(err => {\n    if (err.code === 'ENOENT') return {\n      size: 0,\n      valid: false\n    };\n    throw err;\n  });\n}\nfunction rebuildIndex(cache, opts) {\n  opts.log.silly('verify', 'rebuilding index');\n  return index.ls(cache).then(entries => {\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    };\n    const buckets = {};\n    for (const k in entries) {\n      /* istanbul ignore else */\n      if (hasOwnProperty(entries, k)) {\n        const hashed = index.hashKey(k);\n        const entry = entries[k];\n        const excluded = opts.filter && !opts.filter(entry);\n        excluded && stats.rejectedEntries++;\n        if (buckets[hashed] && !excluded) buckets[hashed].push(entry);else if (buckets[hashed] && excluded) {\n          // skip\n        } else if (excluded) {\n          buckets[hashed] = [];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        } else {\n          buckets[hashed] = [entry];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        }\n      }\n    }\n    return pMap(Object.keys(buckets), key => {\n      return rebuildBucket(cache, buckets[key], stats, opts);\n    }, {\n      concurrency: opts.concurrency\n    }).then(() => stats);\n  });\n}\nfunction rebuildBucket(cache, bucket, stats, opts) {\n  return truncate(bucket._path).then(() => {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return bucket.reduce((promise, entry) => {\n      return promise.then(() => {\n        const content = contentPath(cache, entry.integrity);\n        return stat(content).then(() => {\n          return index.insert(cache, entry.key, entry.integrity, {\n            metadata: entry.metadata,\n            size: entry.size\n          }).then(() => {\n            stats.totalEntries++;\n          });\n        }).catch(err => {\n          if (err.code === 'ENOENT') {\n            stats.rejectedEntries++;\n            stats.missingContent++;\n            return;\n          }\n          throw err;\n        });\n      });\n    }, Promise.resolve());\n  });\n}\nfunction cleanTmp(cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory');\n  return rimraf(path.join(cache, 'tmp'));\n}\nfunction writeVerifile(cache, opts) {\n  const verifile = path.join(cache, '_lastverified');\n  opts.log.silly('verify', 'writing verifile to ' + verifile);\n  try {\n    return writeFile(verifile, '' + +new Date());\n  } finally {\n    fixOwner.chownr.sync(cache, verifile);\n  }\n}\nmodule.exports.lastRun = lastRun;\nfunction lastRun(cache) {\n  return readFile(path.join(cache, '_lastverified'), 'utf8').then(data => new Date(+data));\n}","map":{"version":3,"names":["util","require","pMap","contentPath","fixOwner","fs","fsm","glob","promisify","index","path","rimraf","ssri","hasOwnProperty","obj","key","Object","prototype","call","stat","truncate","writeFile","readFile","verifyOpts","opts","concurrency","log","silly","module","exports","verify","cache","steps","markStartTime","fixPerms","garbageCollect","rebuildIndex","cleanTmp","writeVerifile","markEndTime","reduce","promise","step","i","label","name","start","Date","then","stats","s","keys","forEach","k","end","runTime","Promise","resolve","total","endTime","startTime","mkdirfix","chownr","indexStream","lsStream","liveContent","Set","on","entry","filter","add","integrity","toString","reject","contentDir","join","follow","nodir","nosort","files","verifiedContent","reclaimedCount","reclaimedSize","badContentCount","keptSize","f","split","digest","slice","length","algo","fromHex","has","verifyContent","info","valid","size","filepath","sri","contentInfo","checkStream","ReadStream","catch","err","code","ls","entries","missingContent","rejectedEntries","totalEntries","buckets","hashed","hashKey","excluded","push","_path","bucketPath","rebuildBucket","bucket","content","insert","metadata","verifile","sync","lastRun","data"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/cacache/lib/verify.js"],"sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst pMap = require('p-map')\nconst contentPath = require('./content/path')\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst glob = util.promisify(require('glob'))\nconst index = require('./entry-index')\nconst path = require('path')\nconst rimraf = util.promisify(require('rimraf'))\nconst ssri = require('ssri')\n\nconst hasOwnProperty = (obj, key) =>\n  Object.prototype.hasOwnProperty.call(obj, key)\n\nconst stat = util.promisify(fs.stat)\nconst truncate = util.promisify(fs.truncate)\nconst writeFile = util.promisify(fs.writeFile)\nconst readFile = util.promisify(fs.readFile)\n\nconst verifyOpts = (opts) => ({\n  concurrency: 20,\n  log: { silly () {} },\n  ...opts,\n})\n\nmodule.exports = verify\n\nfunction verify (cache, opts) {\n  opts = verifyOpts(opts)\n  opts.log.silly('verify', 'verifying cache at', cache)\n\n  const steps = [\n    markStartTime,\n    fixPerms,\n    garbageCollect,\n    rebuildIndex,\n    cleanTmp,\n    writeVerifile,\n    markEndTime,\n  ]\n\n  return steps\n    .reduce((promise, step, i) => {\n      const label = step.name\n      const start = new Date()\n      return promise.then((stats) => {\n        return step(cache, opts).then((s) => {\n          s &&\n            Object.keys(s).forEach((k) => {\n              stats[k] = s[k]\n            })\n          const end = new Date()\n          if (!stats.runTime)\n            stats.runTime = {}\n\n          stats.runTime[label] = end - start\n          return Promise.resolve(stats)\n        })\n      })\n    }, Promise.resolve({}))\n    .then((stats) => {\n      stats.runTime.total = stats.endTime - stats.startTime\n      opts.log.silly(\n        'verify',\n        'verification finished for',\n        cache,\n        'in',\n        `${stats.runTime.total}ms`\n      )\n      return stats\n    })\n}\n\nfunction markStartTime (cache, opts) {\n  return Promise.resolve({ startTime: new Date() })\n}\n\nfunction markEndTime (cache, opts) {\n  return Promise.resolve({ endTime: new Date() })\n}\n\nfunction fixPerms (cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions')\n  return fixOwner\n    .mkdirfix(cache, cache)\n    .then(() => {\n      // TODO - fix file permissions too\n      return fixOwner.chownr(cache, cache)\n    })\n    .then(() => null)\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nfunction garbageCollect (cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content')\n  const indexStream = index.lsStream(cache)\n  const liveContent = new Set()\n  indexStream.on('data', (entry) => {\n    if (opts.filter && !opts.filter(entry))\n      return\n\n    liveContent.add(entry.integrity.toString())\n  })\n  return new Promise((resolve, reject) => {\n    indexStream.on('end', resolve).on('error', reject)\n  }).then(() => {\n    const contentDir = contentPath.contentDir(cache)\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true,\n    }).then((files) => {\n      return Promise.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0,\n      }).then((stats) =>\n        pMap(\n          files,\n          (f) => {\n            const split = f.split(/[/\\\\]/)\n            const digest = split.slice(split.length - 3).join('')\n            const algo = split[split.length - 4]\n            const integrity = ssri.fromHex(digest, algo)\n            if (liveContent.has(integrity.toString())) {\n              return verifyContent(f, integrity).then((info) => {\n                if (!info.valid) {\n                  stats.reclaimedCount++\n                  stats.badContentCount++\n                  stats.reclaimedSize += info.size\n                } else {\n                  stats.verifiedContent++\n                  stats.keptSize += info.size\n                }\n                return stats\n              })\n            } else {\n              // No entries refer to this content. We can delete.\n              stats.reclaimedCount++\n              return stat(f).then((s) => {\n                return rimraf(f).then(() => {\n                  stats.reclaimedSize += s.size\n                  return stats\n                })\n              })\n            }\n          },\n          { concurrency: opts.concurrency }\n        ).then(() => stats)\n      )\n    })\n  })\n}\n\nfunction verifyContent (filepath, sri) {\n  return stat(filepath)\n    .then((s) => {\n      const contentInfo = {\n        size: s.size,\n        valid: true,\n      }\n      return ssri\n        .checkStream(new fsm.ReadStream(filepath), sri)\n        .catch((err) => {\n          if (err.code !== 'EINTEGRITY')\n            throw err\n\n          return rimraf(filepath).then(() => {\n            contentInfo.valid = false\n          })\n        })\n        .then(() => contentInfo)\n    })\n    .catch((err) => {\n      if (err.code === 'ENOENT')\n        return { size: 0, valid: false }\n\n      throw err\n    })\n}\n\nfunction rebuildIndex (cache, opts) {\n  opts.log.silly('verify', 'rebuilding index')\n  return index.ls(cache).then((entries) => {\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0,\n    }\n    const buckets = {}\n    for (const k in entries) {\n      /* istanbul ignore else */\n      if (hasOwnProperty(entries, k)) {\n        const hashed = index.hashKey(k)\n        const entry = entries[k]\n        const excluded = opts.filter && !opts.filter(entry)\n        excluded && stats.rejectedEntries++\n        if (buckets[hashed] && !excluded)\n          buckets[hashed].push(entry)\n        else if (buckets[hashed] && excluded) {\n          // skip\n        } else if (excluded) {\n          buckets[hashed] = []\n          buckets[hashed]._path = index.bucketPath(cache, k)\n        } else {\n          buckets[hashed] = [entry]\n          buckets[hashed]._path = index.bucketPath(cache, k)\n        }\n      }\n    }\n    return pMap(\n      Object.keys(buckets),\n      (key) => {\n        return rebuildBucket(cache, buckets[key], stats, opts)\n      },\n      { concurrency: opts.concurrency }\n    ).then(() => stats)\n  })\n}\n\nfunction rebuildBucket (cache, bucket, stats, opts) {\n  return truncate(bucket._path).then(() => {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return bucket.reduce((promise, entry) => {\n      return promise.then(() => {\n        const content = contentPath(cache, entry.integrity)\n        return stat(content)\n          .then(() => {\n            return index\n              .insert(cache, entry.key, entry.integrity, {\n                metadata: entry.metadata,\n                size: entry.size,\n              })\n              .then(() => {\n                stats.totalEntries++\n              })\n          })\n          .catch((err) => {\n            if (err.code === 'ENOENT') {\n              stats.rejectedEntries++\n              stats.missingContent++\n              return\n            }\n            throw err\n          })\n      })\n    }, Promise.resolve())\n  })\n}\n\nfunction cleanTmp (cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory')\n  return rimraf(path.join(cache, 'tmp'))\n}\n\nfunction writeVerifile (cache, opts) {\n  const verifile = path.join(cache, '_lastverified')\n  opts.log.silly('verify', 'writing verifile to ' + verifile)\n  try {\n    return writeFile(verifile, '' + +new Date())\n  } finally {\n    fixOwner.chownr.sync(cache, verifile)\n  }\n}\n\nmodule.exports.lastRun = lastRun\n\nfunction lastRun (cache) {\n  return readFile(path.join(cache, '_lastverified'), 'utf8').then(\n    (data) => new Date(+data)\n  )\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAE5B,MAAMC,IAAI,GAAGD,OAAO,CAAC,OAAO,CAAC;AAC7B,MAAME,WAAW,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAC7C,MAAMG,QAAQ,GAAGH,OAAO,CAAC,kBAAkB,CAAC;AAC5C,MAAMI,EAAE,GAAGJ,OAAO,CAAC,IAAI,CAAC;AACxB,MAAMK,GAAG,GAAGL,OAAO,CAAC,aAAa,CAAC;AAClC,MAAMM,IAAI,GAAGP,IAAI,CAACQ,SAAS,CAACP,OAAO,CAAC,MAAM,CAAC,CAAC;AAC5C,MAAMQ,KAAK,GAAGR,OAAO,CAAC,eAAe,CAAC;AACtC,MAAMS,IAAI,GAAGT,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMU,MAAM,GAAGX,IAAI,CAACQ,SAAS,CAACP,OAAO,CAAC,QAAQ,CAAC,CAAC;AAChD,MAAMW,IAAI,GAAGX,OAAO,CAAC,MAAM,CAAC;AAE5B,MAAMY,cAAc,GAAG,CAACC,GAAG,EAAEC,GAAG,KAC9BC,MAAM,CAACC,SAAS,CAACJ,cAAc,CAACK,IAAI,CAACJ,GAAG,EAAEC,GAAG,CAAC;AAEhD,MAAMI,IAAI,GAAGnB,IAAI,CAACQ,SAAS,CAACH,EAAE,CAACc,IAAI,CAAC;AACpC,MAAMC,QAAQ,GAAGpB,IAAI,CAACQ,SAAS,CAACH,EAAE,CAACe,QAAQ,CAAC;AAC5C,MAAMC,SAAS,GAAGrB,IAAI,CAACQ,SAAS,CAACH,EAAE,CAACgB,SAAS,CAAC;AAC9C,MAAMC,QAAQ,GAAGtB,IAAI,CAACQ,SAAS,CAACH,EAAE,CAACiB,QAAQ,CAAC;AAE5C,MAAMC,UAAU,GAAIC,IAAI,KAAM;EAC5BC,WAAW,EAAE,EAAE;EACfC,GAAG,EAAE;IAAEC,KAAK,GAAI,CAAC;EAAE,CAAC;EACpB,GAAGH;AACL,CAAC,CAAC;AAEFI,MAAM,CAACC,OAAO,GAAGC,MAAM;AAEvB,SAASA,MAAM,CAAEC,KAAK,EAAEP,IAAI,EAAE;EAC5BA,IAAI,GAAGD,UAAU,CAACC,IAAI,CAAC;EACvBA,IAAI,CAACE,GAAG,CAACC,KAAK,CAAC,QAAQ,EAAE,oBAAoB,EAAEI,KAAK,CAAC;EAErD,MAAMC,KAAK,GAAG,CACZC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,YAAY,EACZC,QAAQ,EACRC,aAAa,EACbC,WAAW,CACZ;EAED,OAAOP,KAAK,CACTQ,MAAM,CAAC,CAACC,OAAO,EAAEC,IAAI,EAAEC,CAAC,KAAK;IAC5B,MAAMC,KAAK,GAAGF,IAAI,CAACG,IAAI;IACvB,MAAMC,KAAK,GAAG,IAAIC,IAAI,EAAE;IACxB,OAAON,OAAO,CAACO,IAAI,CAAEC,KAAK,IAAK;MAC7B,OAAOP,IAAI,CAACX,KAAK,EAAEP,IAAI,CAAC,CAACwB,IAAI,CAAEE,CAAC,IAAK;QACnCA,CAAC,IACClC,MAAM,CAACmC,IAAI,CAACD,CAAC,CAAC,CAACE,OAAO,CAAEC,CAAC,IAAK;UAC5BJ,KAAK,CAACI,CAAC,CAAC,GAAGH,CAAC,CAACG,CAAC,CAAC;QACjB,CAAC,CAAC;QACJ,MAAMC,GAAG,GAAG,IAAIP,IAAI,EAAE;QACtB,IAAI,CAACE,KAAK,CAACM,OAAO,EAChBN,KAAK,CAACM,OAAO,GAAG,CAAC,CAAC;QAEpBN,KAAK,CAACM,OAAO,CAACX,KAAK,CAAC,GAAGU,GAAG,GAAGR,KAAK;QAClC,OAAOU,OAAO,CAACC,OAAO,CAACR,KAAK,CAAC;MAC/B,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,EAAEO,OAAO,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CACtBT,IAAI,CAAEC,KAAK,IAAK;IACfA,KAAK,CAACM,OAAO,CAACG,KAAK,GAAGT,KAAK,CAACU,OAAO,GAAGV,KAAK,CAACW,SAAS;IACrDpC,IAAI,CAACE,GAAG,CAACC,KAAK,CACZ,QAAQ,EACR,2BAA2B,EAC3BI,KAAK,EACL,IAAI,EACH,GAAEkB,KAAK,CAACM,OAAO,CAACG,KAAM,IAAG,CAC3B;IACD,OAAOT,KAAK;EACd,CAAC,CAAC;AACN;AAEA,SAAShB,aAAa,CAAEF,KAAK,EAAEP,IAAI,EAAE;EACnC,OAAOgC,OAAO,CAACC,OAAO,CAAC;IAAEG,SAAS,EAAE,IAAIb,IAAI;EAAG,CAAC,CAAC;AACnD;AAEA,SAASR,WAAW,CAAER,KAAK,EAAEP,IAAI,EAAE;EACjC,OAAOgC,OAAO,CAACC,OAAO,CAAC;IAAEE,OAAO,EAAE,IAAIZ,IAAI;EAAG,CAAC,CAAC;AACjD;AAEA,SAASb,QAAQ,CAAEH,KAAK,EAAEP,IAAI,EAAE;EAC9BA,IAAI,CAACE,GAAG,CAACC,KAAK,CAAC,QAAQ,EAAE,0BAA0B,CAAC;EACpD,OAAOvB,QAAQ,CACZyD,QAAQ,CAAC9B,KAAK,EAAEA,KAAK,CAAC,CACtBiB,IAAI,CAAC,MAAM;IACV;IACA,OAAO5C,QAAQ,CAAC0D,MAAM,CAAC/B,KAAK,EAAEA,KAAK,CAAC;EACtC,CAAC,CAAC,CACDiB,IAAI,CAAC,MAAM,IAAI,CAAC;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,cAAc,CAAEJ,KAAK,EAAEP,IAAI,EAAE;EACpCA,IAAI,CAACE,GAAG,CAACC,KAAK,CAAC,QAAQ,EAAE,4BAA4B,CAAC;EACtD,MAAMoC,WAAW,GAAGtD,KAAK,CAACuD,QAAQ,CAACjC,KAAK,CAAC;EACzC,MAAMkC,WAAW,GAAG,IAAIC,GAAG,EAAE;EAC7BH,WAAW,CAACI,EAAE,CAAC,MAAM,EAAGC,KAAK,IAAK;IAChC,IAAI5C,IAAI,CAAC6C,MAAM,IAAI,CAAC7C,IAAI,CAAC6C,MAAM,CAACD,KAAK,CAAC,EACpC;IAEFH,WAAW,CAACK,GAAG,CAACF,KAAK,CAACG,SAAS,CAACC,QAAQ,EAAE,CAAC;EAC7C,CAAC,CAAC;EACF,OAAO,IAAIhB,OAAO,CAAC,CAACC,OAAO,EAAEgB,MAAM,KAAK;IACtCV,WAAW,CAACI,EAAE,CAAC,KAAK,EAAEV,OAAO,CAAC,CAACU,EAAE,CAAC,OAAO,EAAEM,MAAM,CAAC;EACpD,CAAC,CAAC,CAACzB,IAAI,CAAC,MAAM;IACZ,MAAM0B,UAAU,GAAGvE,WAAW,CAACuE,UAAU,CAAC3C,KAAK,CAAC;IAChD,OAAOxB,IAAI,CAACG,IAAI,CAACiE,IAAI,CAACD,UAAU,EAAE,IAAI,CAAC,EAAE;MACvCE,MAAM,EAAE,KAAK;MACbC,KAAK,EAAE,IAAI;MACXC,MAAM,EAAE;IACV,CAAC,CAAC,CAAC9B,IAAI,CAAE+B,KAAK,IAAK;MACjB,OAAOvB,OAAO,CAACC,OAAO,CAAC;QACrBuB,eAAe,EAAE,CAAC;QAClBC,cAAc,EAAE,CAAC;QACjBC,aAAa,EAAE,CAAC;QAChBC,eAAe,EAAE,CAAC;QAClBC,QAAQ,EAAE;MACZ,CAAC,CAAC,CAACpC,IAAI,CAAEC,KAAK,IACZ/C,IAAI,CACF6E,KAAK,EACJM,CAAC,IAAK;QACL,MAAMC,KAAK,GAAGD,CAAC,CAACC,KAAK,CAAC,OAAO,CAAC;QAC9B,MAAMC,MAAM,GAAGD,KAAK,CAACE,KAAK,CAACF,KAAK,CAACG,MAAM,GAAG,CAAC,CAAC,CAACd,IAAI,CAAC,EAAE,CAAC;QACrD,MAAMe,IAAI,GAAGJ,KAAK,CAACA,KAAK,CAACG,MAAM,GAAG,CAAC,CAAC;QACpC,MAAMlB,SAAS,GAAG3D,IAAI,CAAC+E,OAAO,CAACJ,MAAM,EAAEG,IAAI,CAAC;QAC5C,IAAIzB,WAAW,CAAC2B,GAAG,CAACrB,SAAS,CAACC,QAAQ,EAAE,CAAC,EAAE;UACzC,OAAOqB,aAAa,CAACR,CAAC,EAAEd,SAAS,CAAC,CAACvB,IAAI,CAAE8C,IAAI,IAAK;YAChD,IAAI,CAACA,IAAI,CAACC,KAAK,EAAE;cACf9C,KAAK,CAACgC,cAAc,EAAE;cACtBhC,KAAK,CAACkC,eAAe,EAAE;cACvBlC,KAAK,CAACiC,aAAa,IAAIY,IAAI,CAACE,IAAI;YAClC,CAAC,MAAM;cACL/C,KAAK,CAAC+B,eAAe,EAAE;cACvB/B,KAAK,CAACmC,QAAQ,IAAIU,IAAI,CAACE,IAAI;YAC7B;YACA,OAAO/C,KAAK;UACd,CAAC,CAAC;QACJ,CAAC,MAAM;UACL;UACAA,KAAK,CAACgC,cAAc,EAAE;UACtB,OAAO9D,IAAI,CAACkE,CAAC,CAAC,CAACrC,IAAI,CAAEE,CAAC,IAAK;YACzB,OAAOvC,MAAM,CAAC0E,CAAC,CAAC,CAACrC,IAAI,CAAC,MAAM;cAC1BC,KAAK,CAACiC,aAAa,IAAIhC,CAAC,CAAC8C,IAAI;cAC7B,OAAO/C,KAAK;YACd,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ;MACF,CAAC,EACD;QAAExB,WAAW,EAAED,IAAI,CAACC;MAAY,CAAC,CAClC,CAACuB,IAAI,CAAC,MAAMC,KAAK,CAAC,CACpB;IACH,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,SAAS4C,aAAa,CAAEI,QAAQ,EAAEC,GAAG,EAAE;EACrC,OAAO/E,IAAI,CAAC8E,QAAQ,CAAC,CAClBjD,IAAI,CAAEE,CAAC,IAAK;IACX,MAAMiD,WAAW,GAAG;MAClBH,IAAI,EAAE9C,CAAC,CAAC8C,IAAI;MACZD,KAAK,EAAE;IACT,CAAC;IACD,OAAOnF,IAAI,CACRwF,WAAW,CAAC,IAAI9F,GAAG,CAAC+F,UAAU,CAACJ,QAAQ,CAAC,EAAEC,GAAG,CAAC,CAC9CI,KAAK,CAAEC,GAAG,IAAK;MACd,IAAIA,GAAG,CAACC,IAAI,KAAK,YAAY,EAC3B,MAAMD,GAAG;MAEX,OAAO5F,MAAM,CAACsF,QAAQ,CAAC,CAACjD,IAAI,CAAC,MAAM;QACjCmD,WAAW,CAACJ,KAAK,GAAG,KAAK;MAC3B,CAAC,CAAC;IACJ,CAAC,CAAC,CACD/C,IAAI,CAAC,MAAMmD,WAAW,CAAC;EAC5B,CAAC,CAAC,CACDG,KAAK,CAAEC,GAAG,IAAK;IACd,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EACvB,OAAO;MAAER,IAAI,EAAE,CAAC;MAAED,KAAK,EAAE;IAAM,CAAC;IAElC,MAAMQ,GAAG;EACX,CAAC,CAAC;AACN;AAEA,SAASnE,YAAY,CAAEL,KAAK,EAAEP,IAAI,EAAE;EAClCA,IAAI,CAACE,GAAG,CAACC,KAAK,CAAC,QAAQ,EAAE,kBAAkB,CAAC;EAC5C,OAAOlB,KAAK,CAACgG,EAAE,CAAC1E,KAAK,CAAC,CAACiB,IAAI,CAAE0D,OAAO,IAAK;IACvC,MAAMzD,KAAK,GAAG;MACZ0D,cAAc,EAAE,CAAC;MACjBC,eAAe,EAAE,CAAC;MAClBC,YAAY,EAAE;IAChB,CAAC;IACD,MAAMC,OAAO,GAAG,CAAC,CAAC;IAClB,KAAK,MAAMzD,CAAC,IAAIqD,OAAO,EAAE;MACvB;MACA,IAAI7F,cAAc,CAAC6F,OAAO,EAAErD,CAAC,CAAC,EAAE;QAC9B,MAAM0D,MAAM,GAAGtG,KAAK,CAACuG,OAAO,CAAC3D,CAAC,CAAC;QAC/B,MAAMe,KAAK,GAAGsC,OAAO,CAACrD,CAAC,CAAC;QACxB,MAAM4D,QAAQ,GAAGzF,IAAI,CAAC6C,MAAM,IAAI,CAAC7C,IAAI,CAAC6C,MAAM,CAACD,KAAK,CAAC;QACnD6C,QAAQ,IAAIhE,KAAK,CAAC2D,eAAe,EAAE;QACnC,IAAIE,OAAO,CAACC,MAAM,CAAC,IAAI,CAACE,QAAQ,EAC9BH,OAAO,CAACC,MAAM,CAAC,CAACG,IAAI,CAAC9C,KAAK,CAAC,MACxB,IAAI0C,OAAO,CAACC,MAAM,CAAC,IAAIE,QAAQ,EAAE;UACpC;QAAA,CACD,MAAM,IAAIA,QAAQ,EAAE;UACnBH,OAAO,CAACC,MAAM,CAAC,GAAG,EAAE;UACpBD,OAAO,CAACC,MAAM,CAAC,CAACI,KAAK,GAAG1G,KAAK,CAAC2G,UAAU,CAACrF,KAAK,EAAEsB,CAAC,CAAC;QACpD,CAAC,MAAM;UACLyD,OAAO,CAACC,MAAM,CAAC,GAAG,CAAC3C,KAAK,CAAC;UACzB0C,OAAO,CAACC,MAAM,CAAC,CAACI,KAAK,GAAG1G,KAAK,CAAC2G,UAAU,CAACrF,KAAK,EAAEsB,CAAC,CAAC;QACpD;MACF;IACF;IACA,OAAOnD,IAAI,CACTc,MAAM,CAACmC,IAAI,CAAC2D,OAAO,CAAC,EACnB/F,GAAG,IAAK;MACP,OAAOsG,aAAa,CAACtF,KAAK,EAAE+E,OAAO,CAAC/F,GAAG,CAAC,EAAEkC,KAAK,EAAEzB,IAAI,CAAC;IACxD,CAAC,EACD;MAAEC,WAAW,EAAED,IAAI,CAACC;IAAY,CAAC,CAClC,CAACuB,IAAI,CAAC,MAAMC,KAAK,CAAC;EACrB,CAAC,CAAC;AACJ;AAEA,SAASoE,aAAa,CAAEtF,KAAK,EAAEuF,MAAM,EAAErE,KAAK,EAAEzB,IAAI,EAAE;EAClD,OAAOJ,QAAQ,CAACkG,MAAM,CAACH,KAAK,CAAC,CAACnE,IAAI,CAAC,MAAM;IACvC;IACA;IACA,OAAOsE,MAAM,CAAC9E,MAAM,CAAC,CAACC,OAAO,EAAE2B,KAAK,KAAK;MACvC,OAAO3B,OAAO,CAACO,IAAI,CAAC,MAAM;QACxB,MAAMuE,OAAO,GAAGpH,WAAW,CAAC4B,KAAK,EAAEqC,KAAK,CAACG,SAAS,CAAC;QACnD,OAAOpD,IAAI,CAACoG,OAAO,CAAC,CACjBvE,IAAI,CAAC,MAAM;UACV,OAAOvC,KAAK,CACT+G,MAAM,CAACzF,KAAK,EAAEqC,KAAK,CAACrD,GAAG,EAAEqD,KAAK,CAACG,SAAS,EAAE;YACzCkD,QAAQ,EAAErD,KAAK,CAACqD,QAAQ;YACxBzB,IAAI,EAAE5B,KAAK,CAAC4B;UACd,CAAC,CAAC,CACDhD,IAAI,CAAC,MAAM;YACVC,KAAK,CAAC4D,YAAY,EAAE;UACtB,CAAC,CAAC;QACN,CAAC,CAAC,CACDP,KAAK,CAAEC,GAAG,IAAK;UACd,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;YACzBvD,KAAK,CAAC2D,eAAe,EAAE;YACvB3D,KAAK,CAAC0D,cAAc,EAAE;YACtB;UACF;UACA,MAAMJ,GAAG;QACX,CAAC,CAAC;MACN,CAAC,CAAC;IACJ,CAAC,EAAE/C,OAAO,CAACC,OAAO,EAAE,CAAC;EACvB,CAAC,CAAC;AACJ;AAEA,SAASpB,QAAQ,CAAEN,KAAK,EAAEP,IAAI,EAAE;EAC9BA,IAAI,CAACE,GAAG,CAACC,KAAK,CAAC,QAAQ,EAAE,wBAAwB,CAAC;EAClD,OAAOhB,MAAM,CAACD,IAAI,CAACiE,IAAI,CAAC5C,KAAK,EAAE,KAAK,CAAC,CAAC;AACxC;AAEA,SAASO,aAAa,CAAEP,KAAK,EAAEP,IAAI,EAAE;EACnC,MAAMkG,QAAQ,GAAGhH,IAAI,CAACiE,IAAI,CAAC5C,KAAK,EAAE,eAAe,CAAC;EAClDP,IAAI,CAACE,GAAG,CAACC,KAAK,CAAC,QAAQ,EAAE,sBAAsB,GAAG+F,QAAQ,CAAC;EAC3D,IAAI;IACF,OAAOrG,SAAS,CAACqG,QAAQ,EAAE,EAAE,GAAG,CAAC,IAAI3E,IAAI,EAAE,CAAC;EAC9C,CAAC,SAAS;IACR3C,QAAQ,CAAC0D,MAAM,CAAC6D,IAAI,CAAC5F,KAAK,EAAE2F,QAAQ,CAAC;EACvC;AACF;AAEA9F,MAAM,CAACC,OAAO,CAAC+F,OAAO,GAAGA,OAAO;AAEhC,SAASA,OAAO,CAAE7F,KAAK,EAAE;EACvB,OAAOT,QAAQ,CAACZ,IAAI,CAACiE,IAAI,CAAC5C,KAAK,EAAE,eAAe,CAAC,EAAE,MAAM,CAAC,CAACiB,IAAI,CAC5D6E,IAAI,IAAK,IAAI9E,IAAI,CAAC,CAAC8E,IAAI,CAAC,CAC1B;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}