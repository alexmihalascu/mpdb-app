{"ast":null,"code":"const {\n  dirname,\n  resolve\n} = require('path');\nconst fileURLToPath = require('./file-url-to-path/index.js');\nconst fs = require('../fs.js');\n\n// given a path, find the owner of the nearest parent\nconst find = async path => {\n  // if we have no getuid, permissions are irrelevant on this platform\n  if (!process.getuid) {\n    return {};\n  }\n\n  // fs methods accept URL objects with a scheme of file: so we need to unwrap\n  // those into an actual path string before we can resolve it\n  const resolved = path != null && path.href && path.origin ? resolve(fileURLToPath(path)) : resolve(path);\n  let stat;\n  try {\n    stat = await fs.lstat(resolved);\n  } finally {\n    // if we got a stat, return its contents\n    if (stat) {\n      return {\n        uid: stat.uid,\n        gid: stat.gid\n      };\n    }\n\n    // try the parent directory\n    if (resolved !== dirname(resolved)) {\n      return find(dirname(resolved));\n    }\n\n    // no more parents, never got a stat, just return an empty object\n    return {};\n  }\n};\n\n// given a path, uid, and gid update the ownership of the path if necessary\nconst update = async (path, uid, gid) => {\n  // nothing to update, just exit\n  if (uid === undefined && gid === undefined) {\n    return;\n  }\n  try {\n    // see if the permissions are already the same, if they are we don't\n    // need to do anything, so return early\n    const stat = await fs.stat(path);\n    if (uid === stat.uid && gid === stat.gid) {\n      return;\n    }\n  } catch (err) {}\n  try {\n    await fs.chown(path, uid, gid);\n  } catch (err) {}\n};\n\n// accepts a `path` and the `owner` property of an options object and normalizes\n// it into an object with numerical `uid` and `gid`\nconst validate = async (path, input) => {\n  let uid;\n  let gid;\n  if (typeof input === 'string' || typeof input === 'number') {\n    uid = input;\n    gid = input;\n  } else if (input && typeof input === 'object') {\n    uid = input.uid;\n    gid = input.gid;\n  }\n  if (uid === 'inherit' || gid === 'inherit') {\n    const owner = await find(path);\n    if (uid === 'inherit') {\n      uid = owner.uid;\n    }\n    if (gid === 'inherit') {\n      gid = owner.gid;\n    }\n  }\n  return {\n    uid,\n    gid\n  };\n};\nmodule.exports = {\n  find,\n  update,\n  validate\n};","map":{"version":3,"names":["dirname","resolve","require","fileURLToPath","fs","find","path","process","getuid","resolved","href","origin","stat","lstat","uid","gid","update","undefined","err","chown","validate","input","owner","module","exports"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/@npmcli/fs/lib/common/owner.js"],"sourcesContent":["const { dirname, resolve } = require('path')\n\nconst fileURLToPath = require('./file-url-to-path/index.js')\nconst fs = require('../fs.js')\n\n// given a path, find the owner of the nearest parent\nconst find = async (path) => {\n  // if we have no getuid, permissions are irrelevant on this platform\n  if (!process.getuid) {\n    return {}\n  }\n\n  // fs methods accept URL objects with a scheme of file: so we need to unwrap\n  // those into an actual path string before we can resolve it\n  const resolved = path != null && path.href && path.origin\n    ? resolve(fileURLToPath(path))\n    : resolve(path)\n\n  let stat\n\n  try {\n    stat = await fs.lstat(resolved)\n  } finally {\n    // if we got a stat, return its contents\n    if (stat) {\n      return { uid: stat.uid, gid: stat.gid }\n    }\n\n    // try the parent directory\n    if (resolved !== dirname(resolved)) {\n      return find(dirname(resolved))\n    }\n\n    // no more parents, never got a stat, just return an empty object\n    return {}\n  }\n}\n\n// given a path, uid, and gid update the ownership of the path if necessary\nconst update = async (path, uid, gid) => {\n  // nothing to update, just exit\n  if (uid === undefined && gid === undefined) {\n    return\n  }\n\n  try {\n    // see if the permissions are already the same, if they are we don't\n    // need to do anything, so return early\n    const stat = await fs.stat(path)\n    if (uid === stat.uid && gid === stat.gid) {\n      return\n    }\n  } catch (err) {}\n\n  try {\n    await fs.chown(path, uid, gid)\n  } catch (err) {}\n}\n\n// accepts a `path` and the `owner` property of an options object and normalizes\n// it into an object with numerical `uid` and `gid`\nconst validate = async (path, input) => {\n  let uid\n  let gid\n\n  if (typeof input === 'string' || typeof input === 'number') {\n    uid = input\n    gid = input\n  } else if (input && typeof input === 'object') {\n    uid = input.uid\n    gid = input.gid\n  }\n\n  if (uid === 'inherit' || gid === 'inherit') {\n    const owner = await find(path)\n    if (uid === 'inherit') {\n      uid = owner.uid\n    }\n\n    if (gid === 'inherit') {\n      gid = owner.gid\n    }\n  }\n\n  return { uid, gid }\n}\n\nmodule.exports = {\n  find,\n  update,\n  validate,\n}\n"],"mappings":"AAAA,MAAM;EAAEA,OAAO;EAAEC;AAAQ,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AAE5C,MAAMC,aAAa,GAAGD,OAAO,CAAC,6BAA6B,CAAC;AAC5D,MAAME,EAAE,GAAGF,OAAO,CAAC,UAAU,CAAC;;AAE9B;AACA,MAAMG,IAAI,GAAG,MAAOC,IAAI,IAAK;EAC3B;EACA,IAAI,CAACC,OAAO,CAACC,MAAM,EAAE;IACnB,OAAO,CAAC,CAAC;EACX;;EAEA;EACA;EACA,MAAMC,QAAQ,GAAGH,IAAI,IAAI,IAAI,IAAIA,IAAI,CAACI,IAAI,IAAIJ,IAAI,CAACK,MAAM,GACrDV,OAAO,CAACE,aAAa,CAACG,IAAI,CAAC,CAAC,GAC5BL,OAAO,CAACK,IAAI,CAAC;EAEjB,IAAIM,IAAI;EAER,IAAI;IACFA,IAAI,GAAG,MAAMR,EAAE,CAACS,KAAK,CAACJ,QAAQ,CAAC;EACjC,CAAC,SAAS;IACR;IACA,IAAIG,IAAI,EAAE;MACR,OAAO;QAAEE,GAAG,EAAEF,IAAI,CAACE,GAAG;QAAEC,GAAG,EAAEH,IAAI,CAACG;MAAI,CAAC;IACzC;;IAEA;IACA,IAAIN,QAAQ,KAAKT,OAAO,CAACS,QAAQ,CAAC,EAAE;MAClC,OAAOJ,IAAI,CAACL,OAAO,CAACS,QAAQ,CAAC,CAAC;IAChC;;IAEA;IACA,OAAO,CAAC,CAAC;EACX;AACF,CAAC;;AAED;AACA,MAAMO,MAAM,GAAG,OAAOV,IAAI,EAAEQ,GAAG,EAAEC,GAAG,KAAK;EACvC;EACA,IAAID,GAAG,KAAKG,SAAS,IAAIF,GAAG,KAAKE,SAAS,EAAE;IAC1C;EACF;EAEA,IAAI;IACF;IACA;IACA,MAAML,IAAI,GAAG,MAAMR,EAAE,CAACQ,IAAI,CAACN,IAAI,CAAC;IAChC,IAAIQ,GAAG,KAAKF,IAAI,CAACE,GAAG,IAAIC,GAAG,KAAKH,IAAI,CAACG,GAAG,EAAE;MACxC;IACF;EACF,CAAC,CAAC,OAAOG,GAAG,EAAE,CAAC;EAEf,IAAI;IACF,MAAMd,EAAE,CAACe,KAAK,CAACb,IAAI,EAAEQ,GAAG,EAAEC,GAAG,CAAC;EAChC,CAAC,CAAC,OAAOG,GAAG,EAAE,CAAC;AACjB,CAAC;;AAED;AACA;AACA,MAAME,QAAQ,GAAG,OAAOd,IAAI,EAAEe,KAAK,KAAK;EACtC,IAAIP,GAAG;EACP,IAAIC,GAAG;EAEP,IAAI,OAAOM,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC1DP,GAAG,GAAGO,KAAK;IACXN,GAAG,GAAGM,KAAK;EACb,CAAC,MAAM,IAAIA,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7CP,GAAG,GAAGO,KAAK,CAACP,GAAG;IACfC,GAAG,GAAGM,KAAK,CAACN,GAAG;EACjB;EAEA,IAAID,GAAG,KAAK,SAAS,IAAIC,GAAG,KAAK,SAAS,EAAE;IAC1C,MAAMO,KAAK,GAAG,MAAMjB,IAAI,CAACC,IAAI,CAAC;IAC9B,IAAIQ,GAAG,KAAK,SAAS,EAAE;MACrBA,GAAG,GAAGQ,KAAK,CAACR,GAAG;IACjB;IAEA,IAAIC,GAAG,KAAK,SAAS,EAAE;MACrBA,GAAG,GAAGO,KAAK,CAACP,GAAG;IACjB;EACF;EAEA,OAAO;IAAED,GAAG;IAAEC;EAAI,CAAC;AACrB,CAAC;AAEDQ,MAAM,CAACC,OAAO,GAAG;EACfnB,IAAI;EACJW,MAAM;EACNI;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}