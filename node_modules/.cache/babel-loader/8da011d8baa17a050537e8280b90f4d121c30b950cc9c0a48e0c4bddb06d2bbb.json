{"ast":null,"code":"const {\n  dirname\n} = require('path');\nconst fileURLToPath = require('../common/file-url-to-path/index.js');\nconst fs = require('../fs.js');\nconst defaultOptions = {\n  mode: 0o777,\n  recursive: false\n};\nconst mkdir = async (path, opts) => {\n  const options = {\n    ...defaultOptions,\n    ...opts\n  };\n\n  // if we're not in recursive mode, just call the real mkdir with the path and\n  // the mode option only\n  if (!options.recursive) {\n    return fs.mkdir(path, options.mode);\n  }\n  const makeDirectory = async (dir, mode) => {\n    // we can't use dirname directly since these functions support URL\n    // objects with the file: protocol as the path input, so first we get a\n    // string path, then we can call dirname on that\n    const parent = dir != null && dir.href && dir.origin ? dirname(fileURLToPath(dir)) : dirname(dir);\n\n    // if the parent is the dir itself, try to create it. anything but EISDIR\n    // should be rethrown\n    if (parent === dir) {\n      try {\n        await fs.mkdir(dir, opts);\n      } catch (err) {\n        if (err.code !== 'EISDIR') {\n          throw err;\n        }\n      }\n      return undefined;\n    }\n    try {\n      await fs.mkdir(dir, mode);\n      return dir;\n    } catch (err) {\n      // ENOENT means the parent wasn't there, so create that\n      if (err.code === 'ENOENT') {\n        const made = await makeDirectory(parent, mode);\n        await makeDirectory(dir, mode);\n        // return the shallowest path we created, i.e. the result of creating\n        // the parent\n        return made;\n      }\n\n      // an EEXIST means there's already something there\n      // an EROFS means we have a read-only filesystem and can't create a dir\n      // any other error is fatal and we should give up now\n      if (err.code !== 'EEXIST' && err.code !== 'EROFS') {\n        throw err;\n      }\n\n      // stat the directory, if the result is a directory, then we successfully\n      // created this one so return its path. otherwise, we reject with the\n      // original error by ignoring the error in the catch\n      try {\n        const stat = await fs.stat(dir);\n        if (stat.isDirectory()) {\n          // if it already existed, we didn't create anything so return\n          // undefined\n          return undefined;\n        }\n      } catch (_) {}\n\n      // if the thing that's there isn't a directory, then just re-throw\n      throw err;\n    }\n  };\n  return makeDirectory(path, options.mode);\n};\nmodule.exports = mkdir;","map":{"version":3,"names":["dirname","require","fileURLToPath","fs","defaultOptions","mode","recursive","mkdir","path","opts","options","makeDirectory","dir","parent","href","origin","err","code","undefined","made","stat","isDirectory","_","module","exports"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/@npmcli/fs/lib/mkdir/polyfill.js"],"sourcesContent":["const { dirname } = require('path')\n\nconst fileURLToPath = require('../common/file-url-to-path/index.js')\nconst fs = require('../fs.js')\n\nconst defaultOptions = {\n  mode: 0o777,\n  recursive: false,\n}\n\nconst mkdir = async (path, opts) => {\n  const options = { ...defaultOptions, ...opts }\n\n  // if we're not in recursive mode, just call the real mkdir with the path and\n  // the mode option only\n  if (!options.recursive) {\n    return fs.mkdir(path, options.mode)\n  }\n\n  const makeDirectory = async (dir, mode) => {\n    // we can't use dirname directly since these functions support URL\n    // objects with the file: protocol as the path input, so first we get a\n    // string path, then we can call dirname on that\n    const parent = dir != null && dir.href && dir.origin\n      ? dirname(fileURLToPath(dir))\n      : dirname(dir)\n\n    // if the parent is the dir itself, try to create it. anything but EISDIR\n    // should be rethrown\n    if (parent === dir) {\n      try {\n        await fs.mkdir(dir, opts)\n      } catch (err) {\n        if (err.code !== 'EISDIR') {\n          throw err\n        }\n      }\n      return undefined\n    }\n\n    try {\n      await fs.mkdir(dir, mode)\n      return dir\n    } catch (err) {\n      // ENOENT means the parent wasn't there, so create that\n      if (err.code === 'ENOENT') {\n        const made = await makeDirectory(parent, mode)\n        await makeDirectory(dir, mode)\n        // return the shallowest path we created, i.e. the result of creating\n        // the parent\n        return made\n      }\n\n      // an EEXIST means there's already something there\n      // an EROFS means we have a read-only filesystem and can't create a dir\n      // any other error is fatal and we should give up now\n      if (err.code !== 'EEXIST' && err.code !== 'EROFS') {\n        throw err\n      }\n\n      // stat the directory, if the result is a directory, then we successfully\n      // created this one so return its path. otherwise, we reject with the\n      // original error by ignoring the error in the catch\n      try {\n        const stat = await fs.stat(dir)\n        if (stat.isDirectory()) {\n          // if it already existed, we didn't create anything so return\n          // undefined\n          return undefined\n        }\n      } catch (_) {}\n\n      // if the thing that's there isn't a directory, then just re-throw\n      throw err\n    }\n  }\n\n  return makeDirectory(path, options.mode)\n}\n\nmodule.exports = mkdir\n"],"mappings":"AAAA,MAAM;EAAEA;AAAQ,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AAEnC,MAAMC,aAAa,GAAGD,OAAO,CAAC,qCAAqC,CAAC;AACpE,MAAME,EAAE,GAAGF,OAAO,CAAC,UAAU,CAAC;AAE9B,MAAMG,cAAc,GAAG;EACrBC,IAAI,EAAE,KAAK;EACXC,SAAS,EAAE;AACb,CAAC;AAED,MAAMC,KAAK,GAAG,OAAOC,IAAI,EAAEC,IAAI,KAAK;EAClC,MAAMC,OAAO,GAAG;IAAE,GAAGN,cAAc;IAAE,GAAGK;EAAK,CAAC;;EAE9C;EACA;EACA,IAAI,CAACC,OAAO,CAACJ,SAAS,EAAE;IACtB,OAAOH,EAAE,CAACI,KAAK,CAACC,IAAI,EAAEE,OAAO,CAACL,IAAI,CAAC;EACrC;EAEA,MAAMM,aAAa,GAAG,OAAOC,GAAG,EAAEP,IAAI,KAAK;IACzC;IACA;IACA;IACA,MAAMQ,MAAM,GAAGD,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACE,IAAI,IAAIF,GAAG,CAACG,MAAM,GAChDf,OAAO,CAACE,aAAa,CAACU,GAAG,CAAC,CAAC,GAC3BZ,OAAO,CAACY,GAAG,CAAC;;IAEhB;IACA;IACA,IAAIC,MAAM,KAAKD,GAAG,EAAE;MAClB,IAAI;QACF,MAAMT,EAAE,CAACI,KAAK,CAACK,GAAG,EAAEH,IAAI,CAAC;MAC3B,CAAC,CAAC,OAAOO,GAAG,EAAE;QACZ,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;UACzB,MAAMD,GAAG;QACX;MACF;MACA,OAAOE,SAAS;IAClB;IAEA,IAAI;MACF,MAAMf,EAAE,CAACI,KAAK,CAACK,GAAG,EAAEP,IAAI,CAAC;MACzB,OAAOO,GAAG;IACZ,CAAC,CAAC,OAAOI,GAAG,EAAE;MACZ;MACA,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;QACzB,MAAME,IAAI,GAAG,MAAMR,aAAa,CAACE,MAAM,EAAER,IAAI,CAAC;QAC9C,MAAMM,aAAa,CAACC,GAAG,EAAEP,IAAI,CAAC;QAC9B;QACA;QACA,OAAOc,IAAI;MACb;;MAEA;MACA;MACA;MACA,IAAIH,GAAG,CAACC,IAAI,KAAK,QAAQ,IAAID,GAAG,CAACC,IAAI,KAAK,OAAO,EAAE;QACjD,MAAMD,GAAG;MACX;;MAEA;MACA;MACA;MACA,IAAI;QACF,MAAMI,IAAI,GAAG,MAAMjB,EAAE,CAACiB,IAAI,CAACR,GAAG,CAAC;QAC/B,IAAIQ,IAAI,CAACC,WAAW,EAAE,EAAE;UACtB;UACA;UACA,OAAOH,SAAS;QAClB;MACF,CAAC,CAAC,OAAOI,CAAC,EAAE,CAAC;;MAEb;MACA,MAAMN,GAAG;IACX;EACF,CAAC;EAED,OAAOL,aAAa,CAACH,IAAI,EAAEE,OAAO,CAACL,IAAI,CAAC;AAC1C,CAAC;AAEDkB,MAAM,CAACC,OAAO,GAAGjB,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}