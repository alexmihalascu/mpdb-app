{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\nconst os = require('os');\nconst tar = require('tar');\nconst path = require('path');\nconst util = require('util');\nconst stream = require('stream');\nconst crypto = require('crypto');\nconst log = require('npmlog');\nconst semver = require('semver');\nconst fetch = require('make-fetch-happen');\nconst processRelease = require('./process-release');\nconst win = process.platform === 'win32';\nconst streamPipeline = util.promisify(stream.pipeline);\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install(fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release);\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version);\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version);\n  }\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version);\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead');\n    }\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n    return;\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir);\n\n  // the directory where the dev files will be installed\n  const devDir = path.resolve(gyp.devDir, release.versionDir);\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n    try {\n      await fs.promises.stat(devDir);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version);\n        try {\n          return await go();\n        } catch (err) {\n          return rollback(err);\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err);\n      }\n      throw err;\n    }\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n    const installVersionFile = path.resolve(devDir, 'installVersion');\n    let installVersion = 0;\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii');\n      installVersion = parseInt(ver, 10) || 0;\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n    log.verbose('got \"installVersion\"', installVersion);\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling');\n      try {\n        return await go();\n      } catch (err) {\n        return rollback(err);\n      }\n    }\n    log.verbose('install', 'version is good');\n  } else {\n    try {\n      return await go();\n    } catch (err) {\n      return rollback(err);\n    }\n  }\n  async function go() {\n    log.verbose('ensuring nodedir is created', devDir);\n\n    // first create the dir for the node dev files\n    try {\n      const created = await fs.promises.mkdir(devDir, {\n        recursive: true\n      });\n      if (created) {\n        log.verbose('created nodedir', created);\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err);\n      }\n      throw err;\n    }\n\n    // now download the node tarball\n    const tarPath = gyp.opts.tarball;\n    let extractCount = 0;\n    const contentShasums = {};\n    const expectShasums = {};\n\n    // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n    function isValid(path) {\n      const isValid = valid(path);\n      if (isValid) {\n        log.verbose('extracted file from tarball', path);\n        extractCount++;\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path);\n      }\n      return isValid;\n    }\n\n    // download the tarball and extract!\n\n    if (tarPath) {\n      await tar.extract({\n        file: tarPath,\n        strip: 1,\n        filter: isValid,\n        cwd: devDir\n      });\n    } else {\n      try {\n        const res = await download(gyp, release.tarballUrl);\n        if (res.status !== 200) {\n          throw new Error(`${res.status} response downloading ${release.tarballUrl}`);\n        }\n        await streamPipeline(res.body,\n        // content checksum\n        new ShaSum((_, checksum) => {\n          const filename = path.basename(release.tarballUrl).trim();\n          contentShasums[filename] = checksum;\n          log.verbose('content checksum', filename, checksum);\n        }), tar.extract({\n          strip: 1,\n          cwd: devDir,\n          filter: isValid\n        }));\n      } catch (err) {\n        // something went wrong downloading the tarball?\n        if (err.code === 'ENOTFOUND') {\n          throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.');\n        }\n        throw err;\n      }\n    }\n\n    // invoked after the tarball has finished being extracted\n    if (extractCount === 0) {\n      throw new Error('There was a fatal problem while downloading/extracting the tarball');\n    }\n    log.verbose('tarball', 'done parsing tarball');\n    const installVersionPath = path.resolve(devDir, 'installVersion');\n    await Promise.all([\n    // need to download node.lib\n    ...(win ? downloadNodeLib() : []),\n    // write the \"installVersion\" file\n    fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n    // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n    ...(!tarPath || win ? [downloadShasums()] : [])]);\n    log.verbose('download contents checksum', JSON.stringify(contentShasums));\n    // check content shasums\n    for (const k in contentShasums) {\n      log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n      if (contentShasums[k] !== expectShasums[k]) {\n        throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);\n      }\n    }\n    async function downloadShasums() {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n      log.verbose('checksum url', release.shasumsUrl);\n      const res = await download(gyp, release.shasumsUrl);\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`);\n      }\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/);\n        if (items.length !== 2) {\n          return;\n        }\n\n        // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n        const name = items[1].replace(/^\\.\\//, '');\n        expectShasums[name] = items[0];\n      }\n      log.verbose('checksum data', JSON.stringify(expectShasums));\n    }\n    function downloadNodeLib() {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n      const archs = ['ia32', 'x64', 'arm64'];\n      return archs.map(async arch => {\n        const dir = path.resolve(devDir, arch);\n        const targetLibPath = path.resolve(dir, release.name + '.lib');\n        const {\n          libUrl,\n          libPath\n        } = release[arch];\n        const name = `${arch} ${release.name}.lib`;\n        log.verbose(name, 'dir', dir);\n        log.verbose(name, 'url', libUrl);\n        await fs.promises.mkdir(dir, {\n          recursive: true\n        });\n        log.verbose('streaming', name, 'to:', targetLibPath);\n        const res = await download(gyp, libUrl);\n        if (res.status === 403 || res.status === 404) {\n          if (arch === 'arm64') {\n            // Arm64 is a newer platform on Windows and not all node distributions provide it.\n            log.verbose(`${name} was not found in ${libUrl}`);\n          } else {\n            log.warn(`${name} was not found in ${libUrl}`);\n          }\n          return;\n        } else if (res.status !== 200) {\n          throw new Error(`${res.status} status code downloading ${name}`);\n        }\n        return streamPipeline(res.body, new ShaSum((_, checksum) => {\n          contentShasums[libPath] = checksum;\n          log.verbose('content checksum', libPath, checksum);\n        }), fs.createWriteStream(targetLibPath));\n      });\n    } // downloadNodeLib()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid(file) {\n    // header files\n    const extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n  async function rollback(err) {\n    log.warn('install', 'got an error, rolling back install');\n    // roll-back the install if anything went wrong\n    await util.promisify(gyp.commands.remove)([release.versionDir]);\n    throw err;\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  async function eaccesFallback(err) {\n    const noretry = '--node_gyp_internal_noretry';\n    if (argv.indexOf(noretry) !== -1) {\n      throw err;\n    }\n    const tmpdir = os.tmpdir();\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n    let userString = '';\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`;\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n      gyp.todo.push({\n        name: 'remove',\n        args: argv\n      });\n    }\n    return util.promisify(gyp.commands.install)([noretry].concat(argv));\n  }\n}\nclass ShaSum extends stream.Transform {\n  constructor(callback) {\n    super();\n    this._callback = callback;\n    this._digester = crypto.createHash('sha256');\n  }\n  _transform(chunk, _, callback) {\n    this._digester.update(chunk);\n    callback(null, chunk);\n  }\n  _flush(callback) {\n    this._callback(null, this._digester.digest('hex'));\n    callback();\n  }\n}\nasync function download(gyp, url) {\n  log.http('GET', url);\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  };\n  const cafile = gyp.opts.cafile;\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile);\n  }\n  const res = await fetch(url, requestOpts);\n  log.http(res.status, res.url);\n  return res;\n}\nasync function readCAFile(filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8');\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n  return ca.match(re);\n}\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);\n};\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"names":["fs","require","os","tar","path","util","stream","crypto","log","semver","fetch","processRelease","win","process","platform","streamPipeline","promisify","pipeline","install","gyp","argv","release","version","verbose","Error","lt","prerelease","opts","nodedir","versionDir","devDir","resolve","ensure","promises","stat","err","code","go","rollback","eaccesFallback","installVersionFile","installVersion","ver","readFile","parseInt","package","created","mkdir","recursive","tarPath","tarball","extractCount","contentShasums","expectShasums","isValid","valid","silly","extract","file","strip","filter","cwd","res","download","tarballUrl","status","body","ShaSum","_","checksum","filename","basename","trim","installVersionPath","Promise","all","downloadNodeLib","writeFile","downloadShasums","JSON","stringify","k","shasumsUrl","line","text","split","items","length","name","replace","archs","map","arch","dir","targetLibPath","libUrl","libPath","warn","createWriteStream","extname","commands","remove","noretry","indexOf","tmpdir","userString","userInfo","username","e","todo","push","args","concat","Transform","constructor","callback","_callback","_digester","createHash","_transform","chunk","update","_flush","digest","url","http","requestOpts","headers","Connection","proxy","noProxy","noproxy","cafile","ca","readCAFile","re","match","module","exports","then","bind","undefined","test","usage"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/node-gyp/lib/install.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst tar = require('tar')\nconst path = require('path')\nconst util = require('util')\nconst stream = require('stream')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst fetch = require('make-fetch-happen')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst streamPipeline = util.promisify(stream.pipeline)\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install (fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release)\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version)\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version)\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead')\n    }\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  const devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    try {\n      await fs.promises.stat(devDir)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version)\n        try {\n          return await go()\n        } catch (err) {\n          return rollback(err)\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n      throw err\n    }\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n    const installVersionFile = path.resolve(devDir, 'installVersion')\n    let installVersion = 0\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii')\n      installVersion = parseInt(ver, 10) || 0\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n    log.verbose('got \"installVersion\"', installVersion)\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling')\n      try {\n        return await go()\n      } catch (err) {\n        return rollback(err)\n      }\n    }\n    log.verbose('install', 'version is good')\n  } else {\n    try {\n      return await go()\n    } catch (err) {\n      return rollback(err)\n    }\n  }\n\n  async function go () {\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    try {\n      const created = await fs.promises.mkdir(devDir, { recursive: true })\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n\n      throw err\n    }\n\n    // now download the node tarball\n    const tarPath = gyp.opts.tarball\n    let extractCount = 0\n    const contentShasums = {}\n    const expectShasums = {}\n\n    // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n    function isValid (path) {\n      const isValid = valid(path)\n      if (isValid) {\n        log.verbose('extracted file from tarball', path)\n        extractCount++\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path)\n      }\n      return isValid\n    }\n\n    // download the tarball and extract!\n\n    if (tarPath) {\n      await tar.extract({\n        file: tarPath,\n        strip: 1,\n        filter: isValid,\n        cwd: devDir\n      })\n    } else {\n      try {\n        const res = await download(gyp, release.tarballUrl)\n\n        if (res.status !== 200) {\n          throw new Error(`${res.status} response downloading ${release.tarballUrl}`)\n        }\n\n        await streamPipeline(\n          res.body,\n          // content checksum\n          new ShaSum((_, checksum) => {\n            const filename = path.basename(release.tarballUrl).trim()\n            contentShasums[filename] = checksum\n            log.verbose('content checksum', filename, checksum)\n          }),\n          tar.extract({\n            strip: 1,\n            cwd: devDir,\n            filter: isValid\n          })\n        )\n      } catch (err) {\n        // something went wrong downloading the tarball?\n        if (err.code === 'ENOTFOUND') {\n          throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.')\n        }\n        throw err\n      }\n    }\n\n    // invoked after the tarball has finished being extracted\n    if (extractCount === 0) {\n      throw new Error('There was a fatal problem while downloading/extracting the tarball')\n    }\n\n    log.verbose('tarball', 'done parsing tarball')\n\n    const installVersionPath = path.resolve(devDir, 'installVersion')\n    await Promise.all([\n      // need to download node.lib\n      ...(win ? downloadNodeLib() : []),\n      // write the \"installVersion\" file\n      fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n      // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n      ...(!tarPath || win ? [downloadShasums()] : [])\n    ])\n\n    log.verbose('download contents checksum', JSON.stringify(contentShasums))\n    // check content shasums\n    for (const k in contentShasums) {\n      log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n      if (contentShasums[k] !== expectShasums[k]) {\n        throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k])\n      }\n    }\n\n    async function downloadShasums () {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n      log.verbose('checksum url', release.shasumsUrl)\n\n      const res = await download(gyp, release.shasumsUrl)\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`)\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/)\n        if (items.length !== 2) {\n          return\n        }\n\n        // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n        const name = items[1].replace(/^\\.\\//, '')\n        expectShasums[name] = items[0]\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums))\n    }\n\n    function downloadNodeLib () {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n      const archs = ['ia32', 'x64', 'arm64']\n      return archs.map(async (arch) => {\n        const dir = path.resolve(devDir, arch)\n        const targetLibPath = path.resolve(dir, release.name + '.lib')\n        const { libUrl, libPath } = release[arch]\n        const name = `${arch} ${release.name}.lib`\n        log.verbose(name, 'dir', dir)\n        log.verbose(name, 'url', libUrl)\n\n        await fs.promises.mkdir(dir, { recursive: true })\n        log.verbose('streaming', name, 'to:', targetLibPath)\n\n        const res = await download(gyp, libUrl)\n\n        if (res.status === 403 || res.status === 404) {\n          if (arch === 'arm64') {\n            // Arm64 is a newer platform on Windows and not all node distributions provide it.\n            log.verbose(`${name} was not found in ${libUrl}`)\n          } else {\n            log.warn(`${name} was not found in ${libUrl}`)\n          }\n          return\n        } else if (res.status !== 200) {\n          throw new Error(`${res.status} status code downloading ${name}`)\n        }\n\n        return streamPipeline(\n          res.body,\n          new ShaSum((_, checksum) => {\n            contentShasums[libPath] = checksum\n            log.verbose('content checksum', libPath, checksum)\n          }),\n          fs.createWriteStream(targetLibPath)\n        )\n      })\n    } // downloadNodeLib()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    const extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  async function rollback (err) {\n    log.warn('install', 'got an error, rolling back install')\n    // roll-back the install if anything went wrong\n    await util.promisify(gyp.commands.remove)([release.versionDir])\n    throw err\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  async function eaccesFallback (err) {\n    const noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      throw err\n    }\n    const tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    let userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    return util.promisify(gyp.commands.install)([noretry].concat(argv))\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor (callback) {\n    super()\n    this._callback = callback\n    this._digester = crypto.createHash('sha256')\n  }\n\n  _transform (chunk, _, callback) {\n    this._digester.update(chunk)\n    callback(null, chunk)\n  }\n\n  _flush (callback) {\n    this._callback(null, this._digester.digest('hex'))\n    callback()\n  }\n}\n\nasync function download (gyp, url) {\n  log.http('GET', url)\n\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  }\n\n  const cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile)\n  }\n\n  const res = await fetch(url, requestOpts)\n  log.http(res.status, res.url)\n\n  return res\n}\n\nasync function readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8')\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback)\n}\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}