{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\nconst MiniPass = require('minipass');\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];\n\n// TODO: this should really be a hardcoded list of algorithms we support,\n// rather than [a-z0-9].\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nconst SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\\S*]*)$/;\nconst STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/;\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nconst defaultOpts = {\n  algorithms: ['sha512'],\n  error: false,\n  options: [],\n  pickAlgorithm: getPrioritizedHash,\n  sep: ' ',\n  single: false,\n  strict: false\n};\nconst ssriOpts = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    ...defaultOpts,\n    ...opts\n  };\n};\nconst getOptString = options => !options || !options.length ? '' : `?${options.join('?')}`;\nconst _onEnd = Symbol('_onEnd');\nconst _getOptions = Symbol('_getOptions');\nclass IntegrityStream extends MiniPass {\n  constructor(opts) {\n    super();\n    this.size = 0;\n    this.opts = opts;\n\n    // may be overridden later, but set now for class consistency\n    this[_getOptions]();\n\n    // options used for calculating stream.  can't be changed.\n    const {\n      algorithms = defaultOpts.algorithms\n    } = opts;\n    this.algorithms = Array.from(new Set(algorithms.concat(this.algorithm ? [this.algorithm] : [])));\n    this.hashes = this.algorithms.map(crypto.createHash);\n  }\n  [_getOptions]() {\n    const {\n      integrity,\n      size,\n      options\n    } = {\n      ...defaultOpts,\n      ...this.opts\n    };\n\n    // For verification\n    this.sri = integrity ? parse(integrity, this.opts) : null;\n    this.expectedSize = size;\n    this.goodSri = this.sri ? !!Object.keys(this.sri).length : false;\n    this.algorithm = this.goodSri ? this.sri.pickAlgorithm(this.opts) : null;\n    this.digests = this.goodSri ? this.sri[this.algorithm] : null;\n    this.optString = getOptString(options);\n  }\n  emit(ev, data) {\n    if (ev === 'end') this[_onEnd]();\n    return super.emit(ev, data);\n  }\n  write(data) {\n    this.size += data.length;\n    this.hashes.forEach(h => h.update(data));\n    return super.write(data);\n  }\n  [_onEnd]() {\n    if (!this.goodSri) {\n      this[_getOptions]();\n    }\n    const newSri = parse(this.hashes.map((h, i) => {\n      return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`;\n    }).join(' '), this.opts);\n    // Integrity verification mode\n    const match = this.goodSri && newSri.match(this.sri, this.opts);\n    if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n      const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`);\n      err.code = 'EBADSIZE';\n      err.found = this.size;\n      err.expected = this.expectedSize;\n      err.sri = this.sri;\n      this.emit('error', err);\n    } else if (this.sri && !match) {\n      const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`);\n      err.code = 'EINTEGRITY';\n      err.found = newSri;\n      err.expected = this.digests;\n      err.algorithm = this.algorithm;\n      err.sri = this.sri;\n      this.emit('error', err);\n    } else {\n      this.emit('size', this.size);\n      this.emit('integrity', newSri);\n      match && this.emit('verified', match);\n    }\n  }\n}\nclass Hash {\n  get isHash() {\n    return true;\n  }\n  constructor(hash, opts) {\n    opts = ssriOpts(opts);\n    const strict = !!opts.strict;\n    this.source = hash.trim();\n\n    // set default values so that we make V8 happy to\n    // always see a familiar object template.\n    this.digest = '';\n    this.algorithm = '';\n    this.options = [];\n\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n    if (!match) {\n      return;\n    }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) {\n      return;\n    }\n    this.algorithm = match[1];\n    this.digest = match[2];\n    const rawOpts = match[3];\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?');\n    }\n  }\n  hexDigest() {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n  }\n  toJSON() {\n    return this.toString();\n  }\n  toString(opts) {\n    opts = ssriOpts(opts);\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n      // The spec has very restricted productions for algorithms.\n      // https://www.w3.org/TR/CSP2/#source-list-syntax\n      SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n      // Usually, if someone insists on using a \"different\" base64, we\n      // leave it as-is, since there's multiple standards, and the\n      // specified is not a URL-safe variant.\n      // https://www.w3.org/TR/CSP2/#base64_value\n      this.digest.match(BASE64_REGEX) &&\n      // Option syntax is strictly visual chars.\n      // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n      // https://tools.ietf.org/html/rfc5234#appendix-B.1\n      this.options.every(opt => opt.match(VCHAR_REGEX)))) {\n        return '';\n      }\n    }\n    const options = this.options && this.options.length ? `?${this.options.join('?')}` : '';\n    return `${this.algorithm}-${this.digest}${options}`;\n  }\n}\nclass Integrity {\n  get isIntegrity() {\n    return true;\n  }\n  toJSON() {\n    return this.toString();\n  }\n  isEmpty() {\n    return Object.keys(this).length === 0;\n  }\n  toString(opts) {\n    opts = ssriOpts(opts);\n    let sep = opts.sep || ' ';\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ');\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts);\n      }).filter(x => x.length).join(sep);\n    }).filter(x => x.length).join(sep);\n  }\n  concat(integrity, opts) {\n    opts = ssriOpts(opts);\n    const other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n    return parse(`${this.toString(opts)} ${other}`, opts);\n  }\n  hexDigest() {\n    return parse(this, {\n      single: true\n    }).hexDigest();\n  }\n\n  // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n  merge(integrity, opts) {\n    opts = ssriOpts(opts);\n    const other = parse(integrity, opts);\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity');\n        }\n      } else {\n        this[algo] = other[algo];\n      }\n    }\n  }\n  match(integrity, opts) {\n    opts = ssriOpts(opts);\n    const other = parse(integrity, opts);\n    const algo = other.pickAlgorithm(opts);\n    return this[algo] && other[algo] && this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest)) || false;\n  }\n  pickAlgorithm(opts) {\n    opts = ssriOpts(opts);\n    const pickAlgorithm = opts.pickAlgorithm;\n    const keys = Object.keys(this);\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc;\n    });\n  }\n}\nmodule.exports.parse = parse;\nfunction parse(sri, opts) {\n  if (!sri) return null;\n  opts = ssriOpts(opts);\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts);\n  }\n  const hashes = integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts);\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n      acc[algo].push(hash);\n    }\n    return acc;\n  }, new Integrity());\n  return hashes.isEmpty() ? null : hashes;\n}\nmodule.exports.stringify = stringify;\nfunction stringify(obj, opts) {\n  opts = ssriOpts(opts);\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\nmodule.exports.fromHex = fromHex;\nfunction fromHex(hexDigest, algorithm, opts) {\n  opts = ssriOpts(opts);\n  const optString = getOptString(opts.options);\n  return parse(`${algorithm}-${Buffer.from(hexDigest, 'hex').toString('base64')}${optString}`, opts);\n}\nmodule.exports.fromData = fromData;\nfunction fromData(data, opts) {\n  opts = ssriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = getOptString(opts.options);\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64');\n    const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n      acc[algo].push(hash);\n    }\n    return acc;\n  }, new Integrity());\n}\nmodule.exports.fromStream = fromStream;\nfunction fromStream(stream, opts) {\n  opts = ssriOpts(opts);\n  const istream = integrityStream(opts);\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    let sri;\n    istream.on('integrity', s => {\n      sri = s;\n    });\n    istream.on('end', () => resolve(sri));\n    istream.on('data', () => {});\n  });\n}\nmodule.exports.checkData = checkData;\nfunction checkData(data, sri, opts) {\n  opts = ssriOpts(opts);\n  sri = parse(sri, opts);\n  if (!sri || !Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts);\n  const digest = crypto.createHash(algorithm).update(data).digest('base64');\n  const newSri = parse({\n    algorithm,\n    digest\n  });\n  const match = newSri.match(sri, opts);\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`);\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);\n    err.code = 'EINTEGRITY';\n    err.found = newSri;\n    err.expected = sri;\n    err.algorithm = algorithm;\n    err.sri = sri;\n    throw err;\n  }\n}\nmodule.exports.checkStream = checkStream;\nfunction checkStream(stream, sri, opts) {\n  opts = ssriOpts(opts);\n  opts.integrity = sri;\n  sri = parse(sri, opts);\n  if (!sri || !Object.keys(sri).length) {\n    return Promise.reject(Object.assign(new Error('No valid integrity hashes to check against'), {\n      code: 'EINTEGRITY'\n    }));\n  }\n  const checker = integrityStream(opts);\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    let sri;\n    checker.on('verified', s => {\n      sri = s;\n    });\n    checker.on('end', () => resolve(sri));\n    checker.on('data', () => {});\n  });\n}\nmodule.exports.integrityStream = integrityStream;\nfunction integrityStream() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new IntegrityStream(opts);\n}\nmodule.exports.create = createIntegrity;\nfunction createIntegrity(opts) {\n  opts = ssriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = getOptString(opts.options);\n  const hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc));\n      return this;\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64');\n        const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm;\n          if (!acc[algo]) {\n            acc[algo] = [];\n          }\n          acc[algo].push(hash);\n        }\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\nconst NODE_HASHES = new Set(crypto.getHashes());\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n// TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(algo => NODE_HASHES.has(algo));\nfunction getPrioritizedHash(algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":{"version":3,"names":["crypto","require","MiniPass","SPEC_ALGORITHMS","BASE64_REGEX","SRI_REGEX","STRICT_SRI_REGEX","VCHAR_REGEX","defaultOpts","algorithms","error","options","pickAlgorithm","getPrioritizedHash","sep","single","strict","ssriOpts","opts","getOptString","length","join","_onEnd","Symbol","_getOptions","IntegrityStream","constructor","size","Array","from","Set","concat","algorithm","hashes","map","createHash","integrity","sri","parse","expectedSize","goodSri","Object","keys","digests","optString","emit","ev","data","write","forEach","h","update","newSri","i","digest","match","err","Error","code","found","expected","Hash","isHash","hash","source","trim","some","a","rawOpts","slice","split","hexDigest","Buffer","toString","toJSON","x","every","opt","Integrity","isIntegrity","isEmpty","replace","k","prototype","call","filter","other","stringify","merge","algo","find","otherhash","reduce","acc","module","exports","_parse","fullSri","string","push","obj","fromHex","fromData","fromStream","stream","istream","integrityStream","Promise","resolve","reject","pipe","on","s","checkData","assign","checkStream","checker","create","createIntegrity","chunk","enc","shift","NODE_HASHES","getHashes","DEFAULT_PRIORITY","has","algo1","algo2","indexOf","toLowerCase"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/ssri/index.js"],"sourcesContent":["'use strict'\n\nconst crypto = require('crypto')\nconst MiniPass = require('minipass')\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\n// TODO: this should really be a hardcoded list of algorithms we support,\n// rather than [a-z0-9].\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nconst defaultOpts = {\n  algorithms: ['sha512'],\n  error: false,\n  options: [],\n  pickAlgorithm: getPrioritizedHash,\n  sep: ' ',\n  single: false,\n  strict: false\n}\n\nconst ssriOpts = (opts = {}) => ({ ...defaultOpts, ...opts })\n\nconst getOptString = options => !options || !options.length\n  ? ''\n  : `?${options.join('?')}`\n\nconst _onEnd = Symbol('_onEnd')\nconst _getOptions = Symbol('_getOptions')\nclass IntegrityStream extends MiniPass {\n  constructor (opts) {\n    super()\n    this.size = 0\n    this.opts = opts\n\n    // may be overridden later, but set now for class consistency\n    this[_getOptions]()\n\n    // options used for calculating stream.  can't be changed.\n    const { algorithms = defaultOpts.algorithms } = opts\n    this.algorithms = Array.from(\n      new Set(algorithms.concat(this.algorithm ? [this.algorithm] : []))\n    )\n    this.hashes = this.algorithms.map(crypto.createHash)\n  }\n\n  [_getOptions] () {\n    const {\n      integrity,\n      size,\n      options\n    } = { ...defaultOpts, ...this.opts }\n\n    // For verification\n    this.sri = integrity ? parse(integrity, this.opts) : null\n    this.expectedSize = size\n    this.goodSri = this.sri ? !!Object.keys(this.sri).length : false\n    this.algorithm = this.goodSri ? this.sri.pickAlgorithm(this.opts) : null\n    this.digests = this.goodSri ? this.sri[this.algorithm] : null\n    this.optString = getOptString(options)\n  }\n\n  emit (ev, data) {\n    if (ev === 'end') this[_onEnd]()\n    return super.emit(ev, data)\n  }\n\n  write (data) {\n    this.size += data.length\n    this.hashes.forEach(h => h.update(data))\n    return super.write(data)\n  }\n\n  [_onEnd] () {\n    if (!this.goodSri) {\n      this[_getOptions]()\n    }\n    const newSri = parse(this.hashes.map((h, i) => {\n      return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`\n    }).join(' '), this.opts)\n    // Integrity verification mode\n    const match = this.goodSri && newSri.match(this.sri, this.opts)\n    if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n      const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`)\n      err.code = 'EBADSIZE'\n      err.found = this.size\n      err.expected = this.expectedSize\n      err.sri = this.sri\n      this.emit('error', err)\n    } else if (this.sri && !match) {\n      const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = this.digests\n      err.algorithm = this.algorithm\n      err.sri = this.sri\n      this.emit('error', err)\n    } else {\n      this.emit('size', this.size)\n      this.emit('integrity', newSri)\n      match && this.emit('verified', match)\n    }\n  }\n}\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    opts = ssriOpts(opts)\n    const strict = !!opts.strict\n    this.source = hash.trim()\n\n    // set default values so that we make V8 happy to\n    // always see a familiar object template.\n    this.digest = ''\n    this.algorithm = ''\n    this.options = []\n\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n        ? STRICT_SRI_REGEX\n        : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?')\n    }\n  }\n\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n\n  toString (opts) {\n    opts = ssriOpts(opts)\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        this.options.every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n      ? `?${this.options.join('?')}`\n      : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n\n  isEmpty () {\n    return Object.keys(this).length === 0\n  }\n\n  toString (opts) {\n    opts = ssriOpts(opts)\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n\n  concat (integrity, opts) {\n    opts = ssriOpts(opts)\n    const other = typeof integrity === 'string'\n      ? integrity\n      : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n\n  hexDigest () {\n    return parse(this, { single: true }).hexDigest()\n  }\n\n  // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n  merge (integrity, opts) {\n    opts = ssriOpts(opts)\n    const other = parse(integrity, opts)\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash =>\n          other[algo].find(otherhash =>\n            hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity')\n        }\n      } else {\n        this[algo] = other[algo]\n      }\n    }\n  }\n\n  match (integrity, opts) {\n    opts = ssriOpts(opts)\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n\n  pickAlgorithm (opts) {\n    opts = ssriOpts(opts)\n    const pickAlgorithm = opts.pickAlgorithm\n    const keys = Object.keys(this)\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  if (!sri) return null\n  opts = ssriOpts(opts)\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  const hashes = integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n  return hashes.isEmpty() ? null : hashes\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  opts = ssriOpts(opts)\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  opts = ssriOpts(opts)\n  const optString = getOptString(opts.options)\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = ssriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = getOptString(opts.options)\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n      opts\n    )\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = ssriOpts(opts)\n  const istream = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = ssriOpts(opts)\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY'\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({ algorithm, digest })\n  const match = newSri.match(sri, opts)\n  if (match || !opts.error) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = ssriOpts(opts)\n  opts.integrity = sri\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    return Promise.reject(Object.assign(\n      new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      }\n    ))\n  }\n  const checker = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts = {}) {\n  return new IntegrityStream(opts)\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = ssriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = getOptString(opts.options)\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes())\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n].filter(algo => NODE_HASHES.has(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n    ? algo1\n    : algo2\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}