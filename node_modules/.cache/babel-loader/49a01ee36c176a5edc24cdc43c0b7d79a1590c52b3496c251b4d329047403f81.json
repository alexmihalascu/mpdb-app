{"ast":null,"code":"const CacheSemantics = require('http-cache-semantics');\nconst Negotiator = require('negotiator');\nconst ssri = require('ssri');\n\n// HACK: negotiator lazy loads several of its own modules\n// as a micro optimization. we need to be sure that they're\n// in memory as soon as possible at startup so that we do\n// not try to lazy load them after the directory has been\n// retired during a self update of the npm CLI, we do this\n// by calling all of the methods that trigger a lazy load\n// on a fake instance.\nconst preloadNegotiator = new Negotiator({\n  headers: {}\n});\npreloadNegotiator.charsets();\npreloadNegotiator.encodings();\npreloadNegotiator.languages();\npreloadNegotiator.mediaTypes();\n\n// options passed to http-cache-semantics constructor\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true\n};\n\n// a fake empty response, used when only testing the\n// request for storability\nconst emptyResponse = {\n  status: 200,\n  headers: {}\n};\n\n// returns a plain object representation of the Request\nconst requestObject = request => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {}\n  };\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\n\n// returns a plain object representation of the Response\nconst responseObject = response => {\n  const _obj = {\n    status: response.status,\n    headers: {}\n  };\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\nclass CachePolicy {\n  constructor(_ref) {\n    let {\n      entry,\n      request,\n      response,\n      options\n    } = _ref;\n    this.entry = entry;\n    this.request = requestObject(request);\n    this.response = responseObject(response);\n    this.options = options;\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions);\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time;\n    }\n  }\n\n  // static method to quickly determine if a request alone is storable\n  static storable(request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath) return false;\n\n    // user explicitly asked not to cache\n    if (options.cache === 'no-store') return false;\n\n    // we only cache GET and HEAD requests\n    if (!['GET', 'HEAD'].includes(request.method)) return false;\n\n    // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);\n    return policy.storable();\n  }\n\n  // returns true if the policy satisfies the request\n  satisfies(request) {\n    const _req = requestObject(request);\n    if (this.request.headers.host !== _req.headers.host) return false;\n    const negotiatorA = new Negotiator(this.request);\n    const negotiatorB = new Negotiator(_req);\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) return false;\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) return false;\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) return false;\n    if (this.options.integrity) return ssri.parse(this.options.integrity).match(this.entry.integrity);\n    return true;\n  }\n\n  // returns true if the request and response allow caching\n  storable() {\n    return this.policy.storable();\n  }\n\n  // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n  get mustRevalidate() {\n    return !!this.policy._rescc['must-revalidate'];\n  }\n\n  // returns true if the cached response requires revalidation\n  // for the given request\n  needsRevalidation(request) {\n    const _req = requestObject(request);\n    // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n    _req.method = 'GET';\n    return !this.policy.satisfiesWithoutRevalidation(_req);\n  }\n  responseHeaders() {\n    return this.policy.responseHeaders();\n  }\n\n  // returns a new object containing the appropriate headers\n  // to send a revalidation request\n  revalidationHeaders(request) {\n    const _req = requestObject(request);\n    return this.policy.revalidationHeaders(_req);\n  }\n\n  // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n  revalidated(request, response) {\n    const _req = requestObject(request);\n    const _res = responseObject(response);\n    const policy = this.policy.revalidatedPolicy(_req, _res);\n    return !policy.modified;\n  }\n}\nmodule.exports = CachePolicy;","map":{"version":3,"names":["CacheSemantics","require","Negotiator","ssri","preloadNegotiator","headers","charsets","encodings","languages","mediaTypes","policyOptions","shared","ignoreCargoCult","emptyResponse","status","requestObject","request","_obj","method","url","forEach","value","key","responseObject","response","CachePolicy","constructor","entry","options","policy","_responseTime","metadata","time","storable","cachePath","cache","includes","satisfies","_req","host","negotiatorA","negotiatorB","JSON","stringify","integrity","parse","match","mustRevalidate","_rescc","needsRevalidation","satisfiesWithoutRevalidation","responseHeaders","revalidationHeaders","revalidated","_res","revalidatedPolicy","modified","module","exports"],"sources":["/Users/alexmihalascu/Desktop/mpdb-app/node_modules/make-fetch-happen/lib/cache/policy.js"],"sourcesContent":["const CacheSemantics = require('http-cache-semantics')\nconst Negotiator = require('negotiator')\nconst ssri = require('ssri')\n\n// HACK: negotiator lazy loads several of its own modules\n// as a micro optimization. we need to be sure that they're\n// in memory as soon as possible at startup so that we do\n// not try to lazy load them after the directory has been\n// retired during a self update of the npm CLI, we do this\n// by calling all of the methods that trigger a lazy load\n// on a fake instance.\nconst preloadNegotiator = new Negotiator({ headers: {} })\npreloadNegotiator.charsets()\npreloadNegotiator.encodings()\npreloadNegotiator.languages()\npreloadNegotiator.mediaTypes()\n\n// options passed to http-cache-semantics constructor\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true,\n}\n\n// a fake empty response, used when only testing the\n// request for storability\nconst emptyResponse = { status: 200, headers: {} }\n\n// returns a plain object representation of the Request\nconst requestObject = (request) => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {},\n  }\n\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\n// returns a plain object representation of the Response\nconst responseObject = (response) => {\n  const _obj = {\n    status: response.status,\n    headers: {},\n  }\n\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\nclass CachePolicy {\n  constructor ({ entry, request, response, options }) {\n    this.entry = entry\n    this.request = requestObject(request)\n    this.response = responseObject(response)\n    this.options = options\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions)\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time\n    }\n  }\n\n  // static method to quickly determine if a request alone is storable\n  static storable (request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath)\n      return false\n\n    // user explicitly asked not to cache\n    if (options.cache === 'no-store')\n      return false\n\n    // we only cache GET and HEAD requests\n    if (!['GET', 'HEAD'].includes(request.method))\n      return false\n\n    // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions)\n    return policy.storable()\n  }\n\n  // returns true if the policy satisfies the request\n  satisfies (request) {\n    const _req = requestObject(request)\n    if (this.request.headers.host !== _req.headers.host)\n      return false\n\n    const negotiatorA = new Negotiator(this.request)\n    const negotiatorB = new Negotiator(_req)\n\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes()))\n      return false\n\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages()))\n      return false\n\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings()))\n      return false\n\n    if (this.options.integrity)\n      return ssri.parse(this.options.integrity).match(this.entry.integrity)\n\n    return true\n  }\n\n  // returns true if the request and response allow caching\n  storable () {\n    return this.policy.storable()\n  }\n\n  // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n  get mustRevalidate () {\n    return !!this.policy._rescc['must-revalidate']\n  }\n\n  // returns true if the cached response requires revalidation\n  // for the given request\n  needsRevalidation (request) {\n    const _req = requestObject(request)\n    // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n    _req.method = 'GET'\n    return !this.policy.satisfiesWithoutRevalidation(_req)\n  }\n\n  responseHeaders () {\n    return this.policy.responseHeaders()\n  }\n\n  // returns a new object containing the appropriate headers\n  // to send a revalidation request\n  revalidationHeaders (request) {\n    const _req = requestObject(request)\n    return this.policy.revalidationHeaders(_req)\n  }\n\n  // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n  revalidated (request, response) {\n    const _req = requestObject(request)\n    const _res = responseObject(response)\n    const policy = this.policy.revalidatedPolicy(_req, _res)\n    return !policy.modified\n  }\n}\n\nmodule.exports = CachePolicy\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}